<!DOCTYPE html>
<html lang="pt-BR">
	<head>
		
<meta itemprop="name" content="Ambientes por Branch com OpenShift Next Gen usando¬†GitHub">
<meta itemprop="description" content="Esta postagem √© uma continua√ß√£o da &#34;Ambientes por Branch com OpenShift Next Gen&#34;, implementando o processo no GitHub usando Buddy.Works e o OpenShift da GetUp Cloud">


<meta itemprop="datePublished" content="2017-05-07T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-05-07T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1780">

  <meta itemprop="image" content="http://www.lucassabreu.net.br/post/ambientes-por-branch-com-openshift-next-gen-usando-github/header.png">



<meta itemprop="keywords" content="Openshift,Continuous Integration,Continuous Deployment,Github,Buddy Works," />

		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<style type=text/css>body{font-family:monospace;}</style>
		<title>
	Ambientes por Branch com OpenShift Next Gen usando¬†GitHub |
	Lucas dos Santos Abreu
</title>
		
		
		<link rel="stylesheet" href="/css/style.css?rnd=1631468566">
		
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js" integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="/js/index.js"></script>
	</head>
	<body>
		<a class="skip-to-content-link" href="#main"> Skip to content </a>
		
<header class="page-header">
	
		<nav arial-label="primary" role="menu">
			
				
				<a
					href="/"
					
					>Home</a
				>
			
				
				<a
					href="/resume"
					
					>Resume</a
				>
			
				
				<a
					href="https://twitter.com/LucasSantAbreu"
					
					>Twitter</a
				>
			
				
				<a
					href="https://github.com/lucassabreu"
					
					>GitHub</a
				>
			
				
				<a
					href="https://medium.com/@lucassabreu"
					
					>Medium</a
				>
			
				
				<a
					href="https://www.linkedin.com/in/lucassantosabreu"
					
					>LinkedIn</a
				>
			
		</nav>
	
	
</header>

		
	<main id="main">
		<article>
			<header>
				<h1>Ambientes por Branch com OpenShift Next Gen usando¬†GitHub</h1>
				<p>
					
						<span class="reading-time">9 minute read</span>
					
					<span class="published-at">
						Published:
						<time
							>2017-05-07</time
						>
					</span>
				</p>
			</header>

			<div class="content" role="content">
				<p></p>

<figure class="big">
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/header.png" />
	
</figure>


<p><i>Esta postagem √© uma continua√ß√£o da <a href="/post/ambientes-por-branch-com-openshift-next-gen"><strong>Ambientes por Branch com OpenShift Next Gen</strong></a>, a introdu√ß√£o do problema esta l√° e tamb√©m mostro como implementar o processo de deploy usando o GitLab nele, se n√£o viu da uma conferida, vale o investimento* üòâ.</i></p>

<p>Como prometi na outra postagem, vamos criar um processo de deploy de ambientes por branch usando o <a href="https://medium.com/@github">GitHub</a>.</p>

<p>No caso do GitHub, ele cobre &ldquo;apenas&rdquo; a parte de reposit√≥rio de fontes, ele em si n√£o tem integra√ß√£o direta com o Kubernetes/OpenShift, mas possui uma grande gama de op√ß√µes no que diz respeito de ferramentas de CI e CD.</p>

<p>A implementa√ß√£o que vou demonstrar usar√° o <a href="https://medium.com/@BuddyWorks">Buddy</a>, mas pode ser replicada para qualquer outro CI, com dificuldade semelhante. Para o registro de imagens irei usar o <a href="http://hub.docker.com">Docker Hub</a> e novamente o OpenShift da <a href="https://medium.com/@getupcloud">Getup Cloud</a>.</p>

<p>Sobre uma introdu√ß√£o ao Kubernetes/OpenShift pode ver aqui:</p>

<p><a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/"><strong>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää‚Äî‚ÄäParte 1</strong></a></p>

<p>O cliente de linha de comando do OpenShift pode ser baixado em:</p>

<p><a href="https://github.com/openshift/origin/releases"><strong>openshift/origin</strong> origin - Enterprise Kubernetes for Developers</a></p>

<hr />

<p>O que queremos montar √© um ambiente por branch/PR que deve ser facilmente criado e destru√≠do. Para demonstrar criei um reposit√≥rio no GitHub com uma aplica√ß√£o bem simples que apenas retorna uma p√°gina est√°tica, mas √© o suficiente para o objetivo.</p>

<figure >
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/helloworld.png" />
	
		<figcaption><p>retorno do servi√ßo helloworld</p></figcaption>
	
</figure>


<p>E configurei o Buddy para construir uma imagem com base nesse reposit√≥rio e publicar ela como <a href="https://hub.docker.com/r/lucassabreu/k8s-pr-envs/">lucassabreu/k8s-pr-envs</a> no Docker Hub.</p>

<p>Nesse momento o arquivo <code>buddy.yml</code> esta assim:</p>

<pre><code class="language-yaml">- pipeline: &quot;Build&quot;
  trigger_mode: &quot;ON_EVERY_PUSH&quot;
  ref_name: &quot;master&quot;
  actions:
  - action: &quot;Build Docker image&quot;
    type: &quot;DOCKERFILE&quot;
    login: &quot;${DOCKER_HUB_USER}&quot;
    password: &quot;${DOCKER_HUB_PASSWORD}&quot;
    docker_image_tag: &quot;${execution.to_revision.revision}&quot;
    dockerfile_path: &quot;Dockerfile&quot;
    repository: &quot;lucassabreu/k8s-pr-envs&quot;
</code></pre>

<p class="code-legend">buddy.yml</p>

<p>O fonte nesse momento pode ser visto em:</p>

<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v1"><strong>lucassabreu/k8s-pr-envs</strong> v1</a></p>

<hr />

<p>Nesse primeiro momento n√£o possu√≠mos nenhum processo de deploy, seja de teste, produ√ß√£o ou por branch.</p>

<p>Ent√£o vamos adicionar um processo de deploy no OpenShift para o ambiente de produ√ß√£o e testes, sendo que o ambiente de testes √© atualizado automaticamente para os commits na master e o de produ√ß√£o apenas quando um usu√°rio disparar o deploy via interface web do Buddy (<a href="http://app.buddy.works/">http://app.buddy.works/</a>).</p>

<p>Precisamos preparar o OpenShift para montar esse processo, primeiramente criamos um <strong>Namespace</strong>. A forma como criamos um varia de vendor para vendor, no caso do OpenShift da <a href="https://medium.com/@getupcloud">Getup Cloud</a>, basta ir em <a href="https://portal.getupcloud.com/projects">https://portal.getupcloud.com/projects</a> e criar um novo projeto, o nome do projeto ser√° o <strong>Namespace.</strong></p>

<figure class="big">
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/getup-dashboard.png" />
	
</figure>


<p>Tendo um <strong>Namespace</strong> precisamos de uma forma do Buddy se autenticar contra o OpenShift, para isso podemos criar um ServiceAccount e usar o <strong>Token</strong> do mesmo para isso. O script abaixo mostra como criar uma ServiceAccount e resgatar o <strong>Token</strong> usando o CLI do OpenShift:</p>

<pre>
<b>$ oc login https://api.getupcloud.com:443</b>
Authentication required for https://api.getupcloud.com:443 ...
Username: lucas.s.abreu@gmail.com
Password:
Login successful.
...

<b>$ oc project github-k8s-pr-envs #usar o seu projeto</b>
Now using project "github-k8s-pr-envs" on server ...

<b>$ oc create serviceaccount github</b>
serviceaccount "github" created

<b>$ oc policy add-role-to-user admin \
    system:serviceaccount:github-k8s-pr-envs:github</b>

<b>$ oc describe serviceaccount github</b>
Name:  github
Namespace: github-k8s-pr-envs
Labels:  <none>

Image pull secrets: github-dockercfg-vat7r

Mountable secrets:  github-token-d3u3t
                    github-dockercfg-vat7r

Tokens:             github-token-2pimz
                    github-token-d3u3t

<b>$ oc describe secret github-token-d3u3t</b>
Name:  github-token-d3u3t
Namespace: github-k8s-pr-envs
Labels:  <none>
Annotations: kubernetes.io/service-account.name=github
  kubernetes.io/service-account.uid=zzz

Type: kubernetes.io/service-account-token

Data
====
ca.crt:  1066 bytes
namespace: 18 bytes
service-ca.crt: 2182 bytes
token:  <i>token-do-openshift-que-estou-ocultando</i>
</pre>

<p>Agora podemos informar no Buddy algumas vari√°veis para ele disponibilizar para n√≥s depois. Meu painel ficou como abaixo:</p>

<figure >
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/buddy-envs.png" />
	
		<figcaption><p>buddy environments</p></figcaption>
	
</figure>


<p>A URL da API e o dom√≠nio que o OpenShift ir√° utilizar tamb√©m dependem do seu vendor, no meu caso a API est√° em <code>https://api.getupcould.com:443</code> e o dom√≠nio base √© <code>getup.io</code>.</p>

<p>Agora podemos criar os novos pipelines no Buddy. No <code>buddy.yml</code> as linhas abaixo:</p>

<pre><code class="language-yaml">- pipeline: &quot;Deploy Staging&quot;
  trigger_mode: &quot;ON_EVERY_PUSH&quot;
  ref_name: &quot;master&quot;
  actions:
  - action: &quot;Deploy Master to Staging&quot;
    type: &quot;BUILD&quot;
    docker_image_name: &quot;lucassabreu/openshift-k8s-cli&quot;
    docker_image_tag: &quot;latest&quot;
    execute_commands:
    - TAG=&quot;${execution.to_revision.revision}&quot;
      ENV=staging
      OPENSHIFT_NAMESPACE=&quot;${OPENSHIFT_NAMESPACE}&quot;
      OPENSHIFT_API_URL=&quot;${OPENSHIFT_API_URL}&quot;
      OPENSHIFT_TOKEN=&quot;${OPENSHIFT_TOKEN}&quot;
      OPENSHIFT_DOMAIN=&quot;${OPENSHIFT_DOMAIN}&quot;
      ./k8s/deploy
- pipeline: &quot;Deploy Production&quot;
  trigger_mode: &quot;MANUAL&quot;
  ref_name: &quot;master&quot;
  actions:
  - action: &quot;Deploy Master to Production&quot;
    type: &quot;BUILD&quot;
    docker_image_name: &quot;lucassabreu/openshift-k8s-cli&quot;
    docker_image_tag: &quot;latest&quot;
    execute_commands:
    - TAG=&quot;${execution.to_revision.revision}&quot;
      ENV=production
      OPENSHIFT_NAMESPACE=&quot;${OPENSHIFT_NAMESPACE}&quot;
      OPENSHIFT_API_URL=&quot;${OPENSHIFT_API_URL}&quot;
      OPENSHIFT_TOKEN=&quot;${OPENSHIFT_TOKEN}&quot;
      OPENSHIFT_DOMAIN=&quot;${OPENSHIFT_DOMAIN}&quot;
      ./k8s/deploy
</code></pre>

<p class="code-legend">buddy.yml (v2)</p>

<p>Basicamente criei duas novas pipelines, uma chamada <code>Deploy Staging</code> e outra <code>Deploy Production</code> as √∫nicas diferen√ßas entre elas √© que a <code>Deploy Staging</code> √© autom√°tica para todo o commit na master e usa <code>ENV=staging</code> para indicar o ambiente; e <code>Deploy Production</code> √© manual e usa <code>ENV=production</code>. Tamb√©m criei vari√°veis para injetar os valores que informamos antes no Buddy e uma extra <code>COMMIT</code> para que ele consiga identificar qual imagem deve usar.</p>

<p>Essas duas pipelines basicamente chamam o script abaixo:</p>

<pre><code class="language-bash">#!/bin/bash

echo &quot;&gt;&gt; Connecting to OpenShift...&quot;
oc login &quot;$OPENSHIFT_API_URL&quot; --token &quot;$OPENSHIFT_TOKEN&quot;
oc project &quot;$OPENSHIFT_NAMESPACE&quot;

echo &quot;&gt;&gt; Removing old application...&quot;
oc delete all -l &quot;app=$ENV&quot;

IMAGE_TAG=&quot;lucassabreu/k8s-pr-envs:$TAG&quot;
HOSTNAME=&quot;$OPENSHIFT_NAMESPACE-$ENV.$OPENSHIFT_DOMAIN&quot;

if [ &quot;$ENV&quot; = &quot;production&quot; ]; then
    HOSTNAME=$OPENSHIFT_NAMESPACE.$OPENSHIFT_DOMAIN
fi

echo &quot;&gt;&gt; Deploying application...&quot;
sed &quot;
    s|__ENV__|$ENV|;
    s|__IMAGE_TAG__|$IMAGE_TAG|;
    s|__HOSTNAME__|$HOSTNAME|;
    &quot; k8s/full.yml | oc apply -f -

echo &quot;Enviroment $ENV deployed to: http://$HOSTNAME/&quot;
</code></pre>

<p class="code-legend">k8s/deploy</p>

<p>Este script basicamente se autentica contra a API do OpenShift usando o Token que criamos antes, destr√≥i a aplica√ß√£o antiga e executa o deploy
de uma nova.</p>

<p>Para poder identificar quais os componentes de cada ambiente estou marcando eles com a label <code>app=$ENV</code>, dessa forma todos os componentes do ambiente <code>staging</code> est√£o marcados com <code>app=staging</code> e fica f√°cil elimin√°-los e identific√°-los.</p>

<p>√â importante ressaltar que estou usando uma imagem customizada para rodar esses comandos (<code>lucassabreu/openshift-k8s-cli</code>) que basicamente √© um <code>ubuntu</code> com o <code>oc</code> instalado dentro dela.</p>

<p>Tamb√©m estou usando um truque de &ldquo;<em>templating</em>&rdquo; com o YAML que define os ambientes para poder inserir as vari√°veis de cada ambiente nele. Existem outras ferramentas mais avan√ßadas como o <a href="https://github.com/kubernetes/helm">Helm</a>, mas para o meu exemplo templating com <code>sed</code> √© o suficiente.</p>

<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: hw-dpl-__ENV__
  labels:
    app: __ENV__
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: __ENV__
        name: hw-pod
    spec:
      containers:
      - name: hw-container
        image: __IMAGE_TAG__
        imagePullPolicy: Always
        ports:
        - name: web-port
          containerPort: 8080
---
apiVersion: &quot;v1&quot;
kind: Service
metadata:
  name: hw-src-__ENV__
  labels:
    app: __ENV__
spec:
  ports:
    - port: 80
      targetPort: &quot;web-port&quot;
      protocol: TCP
  selector:
    name: hw-pod
    app: __ENV__
---
apiVersion: v1
kind: Route
metadata:
  name: __ENV__
  labels:
    app: __ENV__
spec:
  host: __HOSTNAME__
  to:
    kind: Service
    name: hw-src-__ENV__
</code></pre>

<p class="code-legend">k8s/full.yml</p>

<p>Agora toda vez que √© feito commit na master o ambiente de <em>staging</em> √© automaticamente atualizado, e ficou bem simples atualizar o ambiente <em>production</em>.</p>

<p>Fonte at√© agora:</p>

<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v2"><strong>lucassabreu/k8s-pr-envs</strong> v2</a></p>

<hr />

<p>Agora que temos um processo de <em>build</em> e um de <em>deploy automatizado</em>, vamos adicionar a fun√ß√£o de deploy por branch.</p>

<p>Basicamente precisamos de duas novas etapas no nosso CI, uma para subir o ambiente para uma branch e outro para destruir esse ambiente.</p>

<p>Primeiro vamos preparar o deploy por branch, para isso adicionei as seguintes linhas do <code>buddy.yml</code>:</p>

<pre><code class="language-yaml">- pipeline: &quot;Review&quot;
  trigger_mode: &quot;ON_EVERY_PUSH&quot;
  ref_name: &quot;((?!master).*)&quot;
  actions:
  - action: &quot;Build Docker image&quot;
    type: &quot;DOCKERFILE&quot;
    login: &quot;${DOCKER_HUB_USER}&quot;
    password: &quot;${DOCKER_HUB_PASSWORD}&quot;
    docker_image_tag: &quot;${execution.branch.name}&quot;
    dockerfile_path: &quot;Dockerfile&quot;
    repository: &quot;lucassabreu/k8s-pr-envs&quot;
  - action: &quot;Deploy By Branch&quot;
    type: &quot;BUILD&quot;
    docker_image_name: &quot;lucassabreu/openshift-k8s-cli&quot;
    docker_image_tag: &quot;latest&quot;
    execute_commands:
    - TAG=&quot;${execution.branch.name}&quot;
      ENV=&quot;${execution.branch.name}&quot;
      GITHUB_TOKEN=&quot;${GITHUB_TOKEN}&quot;
      LOG_URL=&quot;${execution.html_url}&quot;
      OPENSHIFT_NAMESPACE=&quot;${OPENSHIFT_NAMESPACE}&quot;
      OPENSHIFT_API_URL=&quot;${OPENSHIFT_API_URL}&quot;
      OPENSHIFT_TOKEN=&quot;${OPENSHIFT_TOKEN}&quot;
      OPENSHIFT_DOMAIN=&quot;${OPENSHIFT_DOMAIN}&quot;
      ./k8s/deploy
</code></pre>

<p>No novo pipeline <em>Review</em> temos um <em>build</em> da imagem e um deploy de um ambiente para a branch em quest√£o, para uma rota pr√≥pria.</p>

<p>Eu acabei juntando essas duas a√ß√µes, pois o build que roda na master vai versionando as imagens por commit, que √© uma pr√°tica comum e que ajudaria a fazer o deploy para produ√ß√£o mais simples, por√©m branchs de desenvolvimento tendem a ser mais ca√≥ticas e iriam poluir muito o registro de imagens (se usar o do AWS seria um custo maior tamb√©m), ent√£o preferi manter uma imagem por branch, at√© para n√£o confundir tamb√©m.</p>

<p>Se eu criar uma nova branch nesse momento, o Buddy automaticamente ir√° montar uma imagem para ela e inseri-la no OpenShift, se o nome da branch for <code>a-change</code> o nome do ambiente <a href="http://github-k8s-pr-envs-a-change.getup.io">http://github-k8s-pr-envs-a-change.getup.io</a> (talvez ainda esteja acess√≠vel).</p>

<p>Eu sei disso porque eu escrevi o script, eu poderia documentar isso no projeto para todos saberem como descobrir as URLs corretas, mas √© mais do que natural esperar erros por esse caminho, um &ldquo;o&rdquo; que vira &ldquo;a&rdquo; na hora de digitar, um nome de branch estranho, etc.</p>

<p>Dessa forma fica dif√≠cil para a equipe de QA acessar aos ambientes por branch toda a vez correndo o risco de errar. Ent√£o fiz algumas altera√ß√µes no <code>k8s/deploy</code> para utilizar a <a href="https://developer.github.com/v3/repos/deployments/">API de Deployments do GitHub</a> para registrar as URLs diretamente nos commits.</p>

<pre><code class="language-shell">if [ ! -z $GITHUB_TOKEN ] &amp;&amp; [ &quot;$ENV&quot; != &quot;production&quot; ] &amp;&amp; [ &quot;$ENV&quot; != &quot;staging&quot; ]; then
    echo &quot;&gt;&gt; Registering $ENV deployment...&quot;

    ID_DEPLOYMENT=$(k8s/github-deployment &quot;lucassabreu/k8s-pr-envs&quot; &quot;$GITHUB_TOKEN&quot; create \
        &quot;$ENV&quot; &quot;$ENV&quot; true | jq &quot;.id&quot;)
    RETURN=$(k8s/github-deployment &quot;lucassabreu/k8s-pr-envs&quot; &quot;$GITHUB_TOKEN&quot; status set \
        &quot;$ID_DEPLOYMENT&quot; success &quot;http://$HOSTNAME/&quot; &quot;$LOG_URL&quot;)
    if [ &quot;$(echo $RETURN | jq &quot;.message&quot;)&quot; != &quot;null&quot; ]; then
        echo $RETURN
        exit 1
    fi
fi

echo &quot;Enviroment $ENV deployed to: http://$HOSTNAME/&quot;
</code></pre>

<p class="code-legend">deploy.sh</p>

<p>Com isso fa√ßo algumas chamadas a API do GitHub usando o <code>k8s/github-deployment</code> (que √© basicamente um facilitador para a API) e consigo registrar o deploy no GitHub.</p>

<p>O Pull Request da branch <code>a-change</code> fica assim:</p>

<figure >
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/github-deployments.png" />
	
</figure>


<p>Nesse bot√£o &ldquo;View deployment&rdquo; est√° o link para a rota que criamos no deploy, e dessa forma fica extremamente f√°cil para a equipe de QA acessar os ambientes.</p>

<p>Fontes at√© agora:</p>

<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v3.1"><strong>lucassabreu/k8s-pr-envs</strong> v3.1</a></p>

<hr />

<p>Ainda fica faltando uma √∫ltima atividade por realizar, que √© destruir o ambiente da branch quando os Testers n√£o mais precisarem deles.</p>

<p>Ent√£o vamos adicionar uma nova pipeline no <code>buddy.yml</code>:</p>

<pre><code class="language-yaml">- pipeline: &quot;Close Review&quot;
  trigger_mode: &quot;MANUAL&quot;
  ref_name: &quot;((?!master).*)&quot;
  actions:
  - action: &quot;Destroy Branch Environment&quot;
    type: &quot;BUILD&quot;
    docker_image_name: &quot;lucassabreu/openshift-k8s-cli&quot;
    docker_image_tag: &quot;latest&quot;
    execute_commands:
    - ENV=&quot;${execution.branch.name}&quot;
      GITHUB_TOKEN=&quot;${GITHUB_TOKEN}&quot;
      OPENSHIFT_NAMESPACE=&quot;${OPENSHIFT_NAMESPACE}&quot;
      OPENSHIFT_API_URL=&quot;${OPENSHIFT_API_URL}&quot;
      OPENSHIFT_TOKEN=&quot;${OPENSHIFT_TOKEN}&quot;
      ./k8s/destroy
</code></pre>

<p>Nesse pipeline manual basicamente chamamos o script <code>k8s/destroy</code> (que esta abaixo) que simplesmente destr√≥i o ambiente inativa ele no GitHub.</p>

<pre><code class="language-bash">#!/bin/bash

echo &quot;&gt;&gt; Connecting to OpenShift...&quot;
oc login &quot;$OPENSHIFT_API_URL&quot; --token &quot;$OPENSHIFT_TOKEN&quot;
oc project &quot;$OPENSHIFT_NAMESPACE&quot;

echo &quot;&gt;&gt; Removing old application...&quot;
oc delete all -l &quot;app=$ENV&quot;

k8s/github-deployment &quot;lucassabreu/k8s-pr-envs&quot; &quot;$GITHUB_TOKEN&quot; inactive &quot;$ENV&quot; &gt;&gt; /dev/null
</code></pre>

<p>Agora podemos chamar ele para eliminar os ambientes de branch em aberto.</p>

<p>Fontes at√© o momento:</p>

<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v4"><strong>lucassabreu/k8s-pr-envs</strong> v4</a></p>

<hr />

<p>Um comportamento que ainda n√£o conseguimos reproduzir usando o Buddy e GitHub √© destruir os ambientes quando o Pull Request √© finalizado.</p>

<p>Para resolver esse problema podemos adicionar um webhook no GitHub e dispararmos o pipeline atrav√©s desse webhook. Isso pode ser feito de v√°rias formas, usando Lambda Functions ou um endpoint para esse fim.</p>

<p>No caso criei um novo Pod com um cont√™iner que criei (<code>lucassabreu/buddy-works-pullrequest-webhook</code>) e associei ela no meu projeto no GitHub.</p>

<figure class="big">
	<img class="lazyload blur-up" data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/webhooks.png" />
	
</figure>


<p>E pronto tenho um processo completo, mesmo que se esque√ßam de derrubar o ambiente no momento que o merge acontecer automaticamente o ambiente
ser√° destru√≠do.</p>

<hr />

<p>Abaixo esta o meu &ldquo;webhook&rdquo; caso opte por um caminho semelhante e poder
ter uma base de como √© a chamada.</p>

<p><a href="https://github.com/lucassabreu/buddy-works-pullrequest-webhook"><strong>lucassabreu/buddy-works-pullrequest-webhook</strong></a></p>

<hr />

<p>Foi mais complexo implementar a integra√ß√£o do OpenShift com o GitHub, mas ainda sim temos um grande ecossistema de integra√ß√µes que nos permitem contornar essa quest√£o, e o resultado continua sendo o esperado.</p>
			</div><section class="share">
	<p>
		Share this post at
		<a
			href="https://twitter.com/share?text=Ambientes%20por%20Branch%20com%20OpenShift%20Next%20Gen%20usando%c2%a0GitHub&nbsp;-&nbsp;Lucas%20dos%20Santos%20Abreu&amp;url=http%3a%2f%2fwww.lucassabreu.net.br%2fpost%2fambientes-por-branch-com-openshift-next-gen-usando-github%2f"
			onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"
		>
			Twitter
		</a>
		<a
			href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.lucassabreu.net.br%2fpost%2fambientes-por-branch-com-openshift-next-gen-usando-github%2f"
			onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
		>
			Facebook
		</a>
		<a
			href="http://pinterest.com/pin/create/button/?url=http%3a%2f%2fwww.lucassabreu.net.br%2fpost%2fambientes-por-branch-com-openshift-next-gen-usando-github%2f&amp;description=Ambientes%20por%20Branch%20com%20OpenShift%20Next%20Gen%20usando%c2%a0GitHub"
			onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;"
		>
			Pinterest
		</a>
	</p>
</section>
<footer>
				
					<section role="comment">
						<p>
							<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lucas-dos-santos-abreu" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
						</p>
					</section>
				
				<section>
	<p>
		Published
		
			by <span itemprop="author"></span>
		
		<time
			datetime="2017-05-07T00:00:00&#43;00:00"
		>
			7 May, 2017
		</time>
		
		
			and tagged
			
				<a href="/tags/openshift">Openshift</a>
			
				<a href="/tags/continuous-integration">Continuous Integration</a>
			
				<a href="/tags/continuous-deployment">Continuous Deployment</a>
			
				<a href="/tags/github">Github</a>
			
				<a href="/tags/buddy-works">Buddy Works</a>
			
		
		using <span itemprop="wordCount">1780</span> words.
	</p>
</section>

			</footer>
		</article>
	</main>
	
	



	<aside>
		<header>Related Content</header>
		<ul>
			
			
				<li>
					<a href="/post/ambientes-por-branch-com-openshift-next-gen/">Ambientes por Branch com OpenShift Next¬†Gen</a> &ndash;
					<time>9 minute read</time>
				</li>
			
				<li>
					<a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4/">Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†4</a> &ndash;
					<time>4 minute read</time>
				</li>
			
				<li>
					<a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/">Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†3</a> &ndash;
					<time>4 minute read</time>
				</li>
			
				<li>
					<a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/">Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†2</a> &ndash;
					<time>5 minute read</time>
				</li>
			
				<li>
					<a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/">Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†1</a> &ndash;
					<time>4 minute read</time>
				</li>
			
				<li>
					<a href="/post/simplificando-setup-projetos-github/">Simplificando o Setup de Projetos no GitHub</a> &ndash;
					<time>2 minute read</time>
				</li>
			
		</ul>
	</aside>



		<footer>
  <p>
    &copy;
    2021 ¬∑
    
    
    This page was generated using <a target="_blank" rel="noopener" href="https://github.com/colorchestra/smol">smol<a> for <a target="_blank" rel="noopener" href="https://gohugo.io/">Hugo</a>.
  </p>
</footer>

	</body>
</html>
