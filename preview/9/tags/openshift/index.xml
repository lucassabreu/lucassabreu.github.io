<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Openshift on Lucas dos Santos Abreu</title><link>https://www.lucassabreu.net.br/preview/9/tags/openshift/</link><description>Recent content in Openshift on Lucas dos Santos Abreu</description><generator>Hugo -- gohugo.io</generator><language>pt-BR</language><lastBuildDate>Sun, 07 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://www.lucassabreu.net.br/preview/9/tags/openshift/index.xml" rel="self" type="application/rss+xml"/><item><title>Ambientes por Branch com OpenShift Next Gen usando¬†GitHub</title><link>https://www.lucassabreu.net.br/preview/9/post/ambientes-por-branch-com-openshift-next-gen-usando-github/</link><pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/ambientes-por-branch-com-openshift-next-gen-usando-github/</guid><description>Esta postagem √© uma continua√ß√£o da "Ambientes por Branch com OpenShift Next Gen", implementando o processo no GitHub usando Buddy.Works e o OpenShift da GetUp Cloud</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/ambientes-por-branch-com-openshift-next-gen-usando-github/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/header.png"
		
			width="1000" height="328"
		
	/>
	
</figure>

<p><i>Esta postagem √© uma continua√ß√£o da <a href="/post/ambientes-por-branch-com-openshift-next-gen"><strong>Ambientes por Branch com OpenShift Next Gen</strong></a>, a introdu√ß√£o do problema esta l√° e tamb√©m mostro como implementar o processo de deploy usando o GitLab nele, se n√£o viu da uma conferida, vale o investimento* üòâ.</i></p>
<p>Como prometi na outra postagem, vamos criar um processo de deploy de ambientes por branch usando o <a href="https://medium.com/@github">GitHub</a>.</p>
<p>No caso do GitHub, ele cobre &ldquo;apenas&rdquo; a parte de reposit√≥rio de fontes, ele em si n√£o tem integra√ß√£o direta com o Kubernetes/OpenShift, mas possui uma grande gama de op√ß√µes no que diz respeito de ferramentas de CI e CD.</p>
<p>A implementa√ß√£o que vou demonstrar usar√° o <a href="https://medium.com/@BuddyWorks">Buddy</a>, mas pode ser replicada para qualquer outro CI, com dificuldade semelhante. Para o registro de imagens irei usar o <a href="http://hub.docker.com">Docker Hub</a> e novamente o OpenShift da <a href="https://medium.com/@getupcloud">Getup Cloud</a>.</p>
<p>Sobre uma introdu√ß√£o ao Kubernetes/OpenShift pode ver aqui:</p>
<p><a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/"><strong>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää‚Äî‚ÄäParte 1</strong></a></p>
<p>O cliente de linha de comando do OpenShift pode ser baixado em:</p>
<p><a href="https://github.com/openshift/origin/releases"><strong>openshift/origin</strong> origin - Enterprise Kubernetes for Developers</a></p>
<hr>
<p>O que queremos montar √© um ambiente por branch/PR que deve ser facilmente criado e destru√≠do. Para demonstrar criei um reposit√≥rio no GitHub com uma aplica√ß√£o bem simples que apenas retorna uma p√°gina est√°tica, mas √© o suficiente para o objetivo.</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/helloworld.png"
		
			width="638" height="365"
		
	/>
	
		<figcaption><p>retorno do servi√ßo helloworld</p></figcaption>
	
</figure>

<p>E configurei o Buddy para construir uma imagem com base nesse reposit√≥rio e publicar ela como <a href="https://hub.docker.com/r/lucassabreu/k8s-pr-envs/">lucassabreu/k8s-pr-envs</a> no Docker Hub.</p>
<p>Nesse momento o arquivo <code>buddy.yml</code> esta assim:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#268bd2">pipeline</span>: <span style="color:#2aa198">&#34;Build&#34;</span>
  <span style="color:#268bd2">trigger_mode</span>: <span style="color:#2aa198">&#34;ON_EVERY_PUSH&#34;</span>
  <span style="color:#268bd2">ref_name</span>: <span style="color:#2aa198">&#34;master&#34;</span>
  <span style="color:#268bd2">actions</span>:
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Build Docker image&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;DOCKERFILE&#34;</span>
    <span style="color:#268bd2">login</span>: <span style="color:#2aa198">&#34;${DOCKER_HUB_USER}&#34;</span>
    <span style="color:#268bd2">password</span>: <span style="color:#2aa198">&#34;${DOCKER_HUB_PASSWORD}&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;${execution.to_revision.revision}&#34;</span>
    <span style="color:#268bd2">dockerfile_path</span>: <span style="color:#2aa198">&#34;Dockerfile&#34;</span>
    <span style="color:#268bd2">repository</span>: <span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs&#34;</span>
</code></pre></div><p class="code-legend">buddy.yml</p>
<p>O fonte nesse momento pode ser visto em:</p>
<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v1"><strong>lucassabreu/k8s-pr-envs</strong> v1</a></p>
<hr>
<p>Nesse primeiro momento n√£o possu√≠mos nenhum processo de deploy, seja de teste, produ√ß√£o ou por branch.</p>
<p>Ent√£o vamos adicionar um processo de deploy no OpenShift para o ambiente de produ√ß√£o e testes, sendo que o ambiente de testes √© atualizado automaticamente para os commits na master e o de produ√ß√£o apenas quando um usu√°rio disparar o deploy via interface web do Buddy (<a href="http://app.buddy.works/">http://app.buddy.works/</a>).</p>
<p>Precisamos preparar o OpenShift para montar esse processo, primeiramente criamos um <strong>Namespace</strong>. A forma como criamos um varia de vendor para vendor, no caso do OpenShift da <a href="https://medium.com/@getupcloud">Getup Cloud</a>, basta ir em <a href="https://portal.getupcloud.com/projects">https://portal.getupcloud.com/projects</a> e criar um novo projeto, o nome do projeto ser√° o <strong>Namespace.</strong></p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/getup-dashboard.png"
		
			width="800" height="286"
		
	/>
	
</figure>

<p>Tendo um <strong>Namespace</strong> precisamos de uma forma do Buddy se autenticar contra o OpenShift, para isso podemos criar um ServiceAccount e usar o <strong>Token</strong> do mesmo para isso. O script abaixo mostra como criar uma ServiceAccount e resgatar o <strong>Token</strong> usando o CLI do OpenShift:</p>
<pre>
<b>$ oc login https://api.getupcloud.com:443</b>
Authentication required for https://api.getupcloud.com:443 ...
Username: lucas.s.abreu@gmail.com
Password:
Login successful.
...

<b>$ oc project github-k8s-pr-envs #usar o seu projeto</b>
Now using project "github-k8s-pr-envs" on server ...

<b>$ oc create serviceaccount github</b>
serviceaccount "github" created

<b>$ oc policy add-role-to-user admin \
    system:serviceaccount:github-k8s-pr-envs:github</b>

<b>$ oc describe serviceaccount github</b>
Name:  github
Namespace: github-k8s-pr-envs
Labels:  <none>

Image pull secrets: github-dockercfg-vat7r

Mountable secrets:  github-token-d3u3t
                    github-dockercfg-vat7r

Tokens:             github-token-2pimz
                    github-token-d3u3t

<b>$ oc describe secret github-token-d3u3t</b>
Name:  github-token-d3u3t
Namespace: github-k8s-pr-envs
Labels:  <none>
Annotations: kubernetes.io/service-account.name=github
  kubernetes.io/service-account.uid=zzz

Type: kubernetes.io/service-account-token

Data
====
ca.crt:  1066 bytes
namespace: 18 bytes
service-ca.crt: 2182 bytes
token:  <i>token-do-openshift-que-estou-ocultando</i>
</pre>
<p>Agora podemos informar no Buddy algumas vari√°veis para ele disponibilizar para n√≥s depois. Meu painel ficou como abaixo:</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/buddy-envs.png"
		
			width="800" height="336"
		
	/>
	
		<figcaption><p>buddy environments</p></figcaption>
	
</figure>

<p>A URL da API e o dom√≠nio que o OpenShift ir√° utilizar tamb√©m dependem do seu vendor, no meu caso a API est√° em <code>https://api.getupcould.com:443</code> e o dom√≠nio base √© <code>getup.io</code>.</p>
<p>Agora podemos criar os novos pipelines no Buddy. No <code>buddy.yml</code> as linhas abaixo:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#268bd2">pipeline</span>: <span style="color:#2aa198">&#34;Deploy Staging&#34;</span>
  <span style="color:#268bd2">trigger_mode</span>: <span style="color:#2aa198">&#34;ON_EVERY_PUSH&#34;</span>
  <span style="color:#268bd2">ref_name</span>: <span style="color:#2aa198">&#34;master&#34;</span>
  <span style="color:#268bd2">actions</span>:
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Deploy Master to Staging&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;BUILD&#34;</span>
    <span style="color:#268bd2">docker_image_name</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-k8s-cli&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;latest&#34;</span>
    <span style="color:#268bd2">execute_commands</span>:
    - TAG=&#34;${execution.to_revision.revision}&#34;
      ENV=staging
      OPENSHIFT_NAMESPACE=&#34;${OPENSHIFT_NAMESPACE}&#34;
      OPENSHIFT_API_URL=&#34;${OPENSHIFT_API_URL}&#34;
      OPENSHIFT_TOKEN=&#34;${OPENSHIFT_TOKEN}&#34;
      OPENSHIFT_DOMAIN=&#34;${OPENSHIFT_DOMAIN}&#34;
      ./k8s/deploy
- <span style="color:#268bd2">pipeline</span>: <span style="color:#2aa198">&#34;Deploy Production&#34;</span>
  <span style="color:#268bd2">trigger_mode</span>: <span style="color:#2aa198">&#34;MANUAL&#34;</span>
  <span style="color:#268bd2">ref_name</span>: <span style="color:#2aa198">&#34;master&#34;</span>
  <span style="color:#268bd2">actions</span>:
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Deploy Master to Production&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;BUILD&#34;</span>
    <span style="color:#268bd2">docker_image_name</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-k8s-cli&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;latest&#34;</span>
    <span style="color:#268bd2">execute_commands</span>:
    - TAG=&#34;${execution.to_revision.revision}&#34;
      ENV=production
      OPENSHIFT_NAMESPACE=&#34;${OPENSHIFT_NAMESPACE}&#34;
      OPENSHIFT_API_URL=&#34;${OPENSHIFT_API_URL}&#34;
      OPENSHIFT_TOKEN=&#34;${OPENSHIFT_TOKEN}&#34;
      OPENSHIFT_DOMAIN=&#34;${OPENSHIFT_DOMAIN}&#34;
      ./k8s/deploy
</code></pre></div><p class="code-legend">buddy.yml (v2)</p>
<p>Basicamente criei duas novas pipelines, uma chamada <code>Deploy Staging</code> e outra <code>Deploy Production</code> as √∫nicas diferen√ßas entre elas √© que a <code>Deploy Staging</code> √© autom√°tica para todo o commit na master e usa <code>ENV=staging</code> para indicar o ambiente; e <code>Deploy Production</code> √© manual e usa <code>ENV=production</code>. Tamb√©m criei vari√°veis para injetar os valores que informamos antes no Buddy e uma extra <code>COMMIT</code> para que ele consiga identificar qual imagem deve usar.</p>
<p>Essas duas pipelines basicamente chamam o script abaixo:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#719e07">#!/bin/bash
</span><span style="color:#719e07"></span>
<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Connecting to OpenShift...&#34;</span>
oc login <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_API_URL</span><span style="color:#2aa198">&#34;</span> --token <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_TOKEN</span><span style="color:#2aa198">&#34;</span>
oc project <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_NAMESPACE</span><span style="color:#2aa198">&#34;</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Removing old application...&#34;</span>
oc delete all -l <span style="color:#2aa198">&#34;app=</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span>

<span style="color:#268bd2">IMAGE_TAG</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs:</span><span style="color:#268bd2">$TAG</span><span style="color:#2aa198">&#34;</span>
<span style="color:#268bd2">HOSTNAME</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_NAMESPACE</span><span style="color:#2aa198">-</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">.</span><span style="color:#268bd2">$OPENSHIFT_DOMAIN</span><span style="color:#2aa198">&#34;</span>

<span style="color:#719e07">if</span> <span style="color:#719e07">[</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> <span style="color:#719e07">=</span> <span style="color:#2aa198">&#34;production&#34;</span> <span style="color:#719e07">]</span>; <span style="color:#719e07">then</span>
    <span style="color:#268bd2">HOSTNAME</span><span style="color:#719e07">=</span><span style="color:#268bd2">$OPENSHIFT_NAMESPACE</span>.<span style="color:#268bd2">$OPENSHIFT_DOMAIN</span>
<span style="color:#719e07">fi</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Deploying application...&#34;</span>
sed <span style="color:#2aa198">&#34;
</span><span style="color:#2aa198">    s|__ENV__|</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">    s|__IMAGE_TAG__|</span><span style="color:#268bd2">$IMAGE_TAG</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">    s|__HOSTNAME__|</span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">    &#34;</span> k8s/full.yml | oc apply -f -

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;Enviroment </span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198"> deployed to: http://</span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">/&#34;</span>
</code></pre></div><p class="code-legend">k8s/deploy</p>
<p>Este script basicamente se autentica contra a API do OpenShift usando o Token que criamos antes, destr√≥i a aplica√ß√£o antiga e executa o deploy
de uma nova.</p>
<p>Para poder identificar quais os componentes de cada ambiente estou marcando eles com a label <code>app=$ENV</code>, dessa forma todos os componentes do ambiente <code>staging</code> est√£o marcados com <code>app=staging</code> e fica f√°cil elimin√°-los e identific√°-los.</p>
<p>√â importante ressaltar que estou usando uma imagem customizada para rodar esses comandos (<code>lucassabreu/openshift-k8s-cli</code>) que basicamente √© um <code>ubuntu</code> com o <code>oc</code> instalado dentro dela.</p>
<p>Tamb√©m estou usando um truque de &ldquo;<em>templating</em>&rdquo; com o YAML que define os ambientes para poder inserir as vari√°veis de cada ambiente nele. Existem outras ferramentas mais avan√ßadas como o <a href="https://github.com/kubernetes/helm">Helm</a>, mas para o meu exemplo templating com <code>sed</code> √© o suficiente.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: hw-dpl-__ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">app</span>: __ENV__
        <span style="color:#268bd2">name</span>: hw-pod
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
      - <span style="color:#268bd2">name</span>: hw-container
        <span style="color:#268bd2">image</span>: __IMAGE_TAG__
        <span style="color:#268bd2">imagePullPolicy</span>: Always
        <span style="color:#268bd2">ports</span>:
        - <span style="color:#268bd2">name</span>: web-port
          <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">8080</span>
---
<span style="color:#268bd2">apiVersion</span>: <span style="color:#2aa198">&#34;v1&#34;</span>
<span style="color:#268bd2">kind</span>: Service
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: hw-src-__ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">ports</span>:
    - <span style="color:#268bd2">port</span>: <span style="color:#2aa198">80</span>
      <span style="color:#268bd2">targetPort</span>: <span style="color:#2aa198">&#34;web-port&#34;</span>
      <span style="color:#268bd2">protocol</span>: TCP
  <span style="color:#268bd2">selector</span>:
    <span style="color:#268bd2">name</span>: hw-pod
    <span style="color:#268bd2">app</span>: __ENV__
---
<span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: Route
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: __ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">host</span>: __HOSTNAME__
  <span style="color:#268bd2">to</span>:
    <span style="color:#268bd2">kind</span>: Service
    <span style="color:#268bd2">name</span>: hw-src-__ENV__
</code></pre></div><p class="code-legend">k8s/full.yml</p>
<p>Agora toda vez que √© feito commit na master o ambiente de <em>staging</em> √© automaticamente atualizado, e ficou bem simples atualizar o ambiente <em>production</em>.</p>
<p>Fonte at√© agora:</p>
<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v2"><strong>lucassabreu/k8s-pr-envs</strong> v2</a></p>
<hr>
<p>Agora que temos um processo de <em>build</em> e um de <em>deploy automatizado</em>, vamos adicionar a fun√ß√£o de deploy por branch.</p>
<p>Basicamente precisamos de duas novas etapas no nosso CI, uma para subir o ambiente para uma branch e outro para destruir esse ambiente.</p>
<p>Primeiro vamos preparar o deploy por branch, para isso adicionei as seguintes linhas do <code>buddy.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#268bd2">pipeline</span>: <span style="color:#2aa198">&#34;Review&#34;</span>
  <span style="color:#268bd2">trigger_mode</span>: <span style="color:#2aa198">&#34;ON_EVERY_PUSH&#34;</span>
  <span style="color:#268bd2">ref_name</span>: <span style="color:#2aa198">&#34;((?!master).*)&#34;</span>
  <span style="color:#268bd2">actions</span>:
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Build Docker image&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;DOCKERFILE&#34;</span>
    <span style="color:#268bd2">login</span>: <span style="color:#2aa198">&#34;${DOCKER_HUB_USER}&#34;</span>
    <span style="color:#268bd2">password</span>: <span style="color:#2aa198">&#34;${DOCKER_HUB_PASSWORD}&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;${execution.branch.name}&#34;</span>
    <span style="color:#268bd2">dockerfile_path</span>: <span style="color:#2aa198">&#34;Dockerfile&#34;</span>
    <span style="color:#268bd2">repository</span>: <span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs&#34;</span>
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Deploy By Branch&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;BUILD&#34;</span>
    <span style="color:#268bd2">docker_image_name</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-k8s-cli&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;latest&#34;</span>
    <span style="color:#268bd2">execute_commands</span>:
    - TAG=&#34;${execution.branch.name}&#34;
      ENV=&#34;${execution.branch.name}&#34;
      GITHUB_TOKEN=&#34;${GITHUB_TOKEN}&#34;
      LOG_URL=&#34;${execution.html_url}&#34;
      OPENSHIFT_NAMESPACE=&#34;${OPENSHIFT_NAMESPACE}&#34;
      OPENSHIFT_API_URL=&#34;${OPENSHIFT_API_URL}&#34;
      OPENSHIFT_TOKEN=&#34;${OPENSHIFT_TOKEN}&#34;
      OPENSHIFT_DOMAIN=&#34;${OPENSHIFT_DOMAIN}&#34;
      ./k8s/deploy
</code></pre></div><p>No novo pipeline <em>Review</em> temos um <em>build</em> da imagem e um deploy de um ambiente para a branch em quest√£o, para uma rota pr√≥pria.</p>
<p>Eu acabei juntando essas duas a√ß√µes, pois o build que roda na master vai versionando as imagens por commit, que √© uma pr√°tica comum e que ajudaria a fazer o deploy para produ√ß√£o mais simples, por√©m branchs de desenvolvimento tendem a ser mais ca√≥ticas e iriam poluir muito o registro de imagens (se usar o do AWS seria um custo maior tamb√©m), ent√£o preferi manter uma imagem por branch, at√© para n√£o confundir tamb√©m.</p>
<p>Se eu criar uma nova branch nesse momento, o Buddy automaticamente ir√° montar uma imagem para ela e inseri-la no OpenShift, se o nome da branch for <code>a-change</code> o nome do ambiente <a href="http://github-k8s-pr-envs-a-change.getup.io">http://github-k8s-pr-envs-a-change.getup.io</a> (talvez ainda esteja acess√≠vel).</p>
<p>Eu sei disso porque eu escrevi o script, eu poderia documentar isso no projeto para todos saberem como descobrir as URLs corretas, mas √© mais do que natural esperar erros por esse caminho, um &ldquo;o&rdquo; que vira &ldquo;a&rdquo; na hora de digitar, um nome de branch estranho, etc.</p>
<p>Dessa forma fica dif√≠cil para a equipe de QA acessar aos ambientes por branch toda a vez correndo o risco de errar. Ent√£o fiz algumas altera√ß√µes no <code>k8s/deploy</code> para utilizar a <a href="https://developer.github.com/v3/repos/deployments/">API de Deployments do GitHub</a> para registrar as URLs diretamente nos commits.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#719e07">if</span> <span style="color:#719e07">[</span> ! -z <span style="color:#268bd2">$GITHUB_TOKEN</span> <span style="color:#719e07">]</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">[</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> !<span style="color:#719e07">=</span> <span style="color:#2aa198">&#34;production&#34;</span> <span style="color:#719e07">]</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">[</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> !<span style="color:#719e07">=</span> <span style="color:#2aa198">&#34;staging&#34;</span> <span style="color:#719e07">]</span>; <span style="color:#719e07">then</span>
    <span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Registering </span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198"> deployment...&#34;</span>

    <span style="color:#268bd2">ID_DEPLOYMENT</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span>k8s/github-deployment <span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs&#34;</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$GITHUB_TOKEN</span><span style="color:#2aa198">&#34;</span> create <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>        <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> <span style="color:#b58900">true</span> | jq <span style="color:#2aa198">&#34;.id&#34;</span><span style="color:#719e07">)</span>
    <span style="color:#268bd2">RETURN</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span>k8s/github-deployment <span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs&#34;</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$GITHUB_TOKEN</span><span style="color:#2aa198">&#34;</span> status <span style="color:#b58900">set</span> <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>        <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ID_DEPLOYMENT</span><span style="color:#2aa198">&#34;</span> success <span style="color:#2aa198">&#34;http://</span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">/&#34;</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$LOG_URL</span><span style="color:#2aa198">&#34;</span><span style="color:#719e07">)</span>
    <span style="color:#719e07">if</span> <span style="color:#719e07">[</span> <span style="color:#2aa198">&#34;</span><span style="color:#719e07">$(</span><span style="color:#b58900">echo</span> <span style="color:#268bd2">$RETURN</span> | jq <span style="color:#2aa198">&#34;.message&#34;</span><span style="color:#719e07">)</span><span style="color:#2aa198">&#34;</span> !<span style="color:#719e07">=</span> <span style="color:#2aa198">&#34;null&#34;</span> <span style="color:#719e07">]</span>; <span style="color:#719e07">then</span>
        <span style="color:#b58900">echo</span> <span style="color:#268bd2">$RETURN</span>
        <span style="color:#b58900">exit</span> <span style="color:#2aa198">1</span>
    <span style="color:#719e07">fi</span>
<span style="color:#719e07">fi</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;Enviroment </span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198"> deployed to: http://</span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">/&#34;</span>
</code></pre></div><p class="code-legend">deploy.sh</p>
<p>Com isso fa√ßo algumas chamadas a API do GitHub usando o <code>k8s/github-deployment</code> (que √© basicamente um facilitador para a API) e consigo registrar o deploy no GitHub.</p>
<p>O Pull Request da branch <code>a-change</code> fica assim:</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/github-deployments.png"
		
			width="800" height="571"
		
	/>
	
</figure>

<p>Nesse bot√£o &ldquo;View deployment&rdquo; est√° o link para a rota que criamos no deploy, e dessa forma fica extremamente f√°cil para a equipe de QA acessar os ambientes.</p>
<p>Fontes at√© agora:</p>
<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v3.1"><strong>lucassabreu/k8s-pr-envs</strong> v3.1</a></p>
<hr>
<p>Ainda fica faltando uma √∫ltima atividade por realizar, que √© destruir o ambiente da branch quando os Testers n√£o mais precisarem deles.</p>
<p>Ent√£o vamos adicionar uma nova pipeline no <code>buddy.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#268bd2">pipeline</span>: <span style="color:#2aa198">&#34;Close Review&#34;</span>
  <span style="color:#268bd2">trigger_mode</span>: <span style="color:#2aa198">&#34;MANUAL&#34;</span>
  <span style="color:#268bd2">ref_name</span>: <span style="color:#2aa198">&#34;((?!master).*)&#34;</span>
  <span style="color:#268bd2">actions</span>:
  - <span style="color:#268bd2">action</span>: <span style="color:#2aa198">&#34;Destroy Branch Environment&#34;</span>
    <span style="color:#268bd2">type</span>: <span style="color:#2aa198">&#34;BUILD&#34;</span>
    <span style="color:#268bd2">docker_image_name</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-k8s-cli&#34;</span>
    <span style="color:#268bd2">docker_image_tag</span>: <span style="color:#2aa198">&#34;latest&#34;</span>
    <span style="color:#268bd2">execute_commands</span>:
    - ENV=&#34;${execution.branch.name}&#34;
      GITHUB_TOKEN=&#34;${GITHUB_TOKEN}&#34;
      OPENSHIFT_NAMESPACE=&#34;${OPENSHIFT_NAMESPACE}&#34;
      OPENSHIFT_API_URL=&#34;${OPENSHIFT_API_URL}&#34;
      OPENSHIFT_TOKEN=&#34;${OPENSHIFT_TOKEN}&#34;
      ./k8s/destroy
</code></pre></div><p>Nesse pipeline manual basicamente chamamos o script <code>k8s/destroy</code> (que esta abaixo) que simplesmente destr√≥i o ambiente inativa ele no GitHub.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#719e07">#!/bin/bash
</span><span style="color:#719e07"></span>
<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Connecting to OpenShift...&#34;</span>
oc login <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_API_URL</span><span style="color:#2aa198">&#34;</span> --token <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_TOKEN</span><span style="color:#2aa198">&#34;</span>
oc project <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$OPENSHIFT_NAMESPACE</span><span style="color:#2aa198">&#34;</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Removing old application...&#34;</span>
oc delete all -l <span style="color:#2aa198">&#34;app=</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span>

k8s/github-deployment <span style="color:#2aa198">&#34;lucassabreu/k8s-pr-envs&#34;</span> <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$GITHUB_TOKEN</span><span style="color:#2aa198">&#34;</span> inactive <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">&#34;</span> &gt;&gt; /dev/null
</code></pre></div><p>Agora podemos chamar ele para eliminar os ambientes de branch em aberto.</p>
<p>Fontes at√© o momento:</p>
<p><a href="https://github.com/lucassabreu/k8s-pr-envs/tree/v4"><strong>lucassabreu/k8s-pr-envs</strong> v4</a></p>
<hr>
<p>Um comportamento que ainda n√£o conseguimos reproduzir usando o Buddy e GitHub √© destruir os ambientes quando o Pull Request √© finalizado.</p>
<p>Para resolver esse problema podemos adicionar um webhook no GitHub e dispararmos o pipeline atrav√©s desse webhook. Isso pode ser feito de v√°rias formas, usando Lambda Functions ou um endpoint para esse fim.</p>
<p>No caso criei um novo Pod com um cont√™iner que criei (<code>lucassabreu/buddy-works-pullrequest-webhook</code>) e associei ela no meu projeto no GitHub.</p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen-usando-github/webhooks.png"
		
			width="1000" height="296"
		
	/>
	
</figure>

<p>E pronto tenho um processo completo, mesmo que se esque√ßam de derrubar o ambiente no momento que o merge acontecer automaticamente o ambiente
ser√° destru√≠do.</p>
<hr>
<p>Abaixo esta o meu &ldquo;webhook&rdquo; caso opte por um caminho semelhante e poder
ter uma base de como √© a chamada.</p>
<p><a href="https://github.com/lucassabreu/buddy-works-pullrequest-webhook"><strong>lucassabreu/buddy-works-pullrequest-webhook</strong></a></p>
<hr>
<p>Foi mais complexo implementar a integra√ß√£o do OpenShift com o GitHub, mas ainda sim temos um grande ecossistema de integra√ß√µes que nos permitem contornar essa quest√£o, e o resultado continua sendo o esperado.</p>]]></content:encoded></item><item><title>Ambientes por Branch com OpenShift Next¬†Gen</title><link>https://www.lucassabreu.net.br/preview/9/post/ambientes-por-branch-com-openshift-next-gen/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/ambientes-por-branch-com-openshift-next-gen/</guid><description>Como melhorar o processo de Pull Request usando deploys por branch usando OpenShift Next Gen e Continuous Integration</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/ambientes-por-branch-com-openshift-next-gen/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/header.png"
		
			width="1000" height="328"
		
	/>
	
</figure>

<p>Hoje na <a href="https://blog.coderockr.com">Coderockr</a> utilizamos <a href="https://blog.coderockr.com/a-import%C3%A2ncia-da-revis%C3%A3o-de-c%C3%B3digo-a1a8b41ed7ff">Pull Requests e Code Reviews</a> como uma ferramenta de qualidade nos nossos desenvolvimentos, e tem garantido resultados nesse sentido.</p>
<p>Mas mesmo com esse processo eventualmente temos de lidar com alguns problemas como, por exemplo, fun√ß√µes que interferem umas nas outras depois de aprovadas, permitir que os Testers possam avaliar as melhorias, e garantir que todos as mudan√ßas feitas na branch principal podem ser enviadas para produ√ß√£o.</p>
<p>Esses problemas podem ser reduzidos, ou at√© eliminados; se, mesmo antes de aprovar os PRs; os Testers conseguissem trabalhar sobre essas melhorias e s√≥ repassadas para a branch principal ap√≥s a aprova√ß√£o deles.</p>
<p>Desse modo o fonte principal n√£o s√≥ passou pelo Review de outros desenvolvedores, como foi testado pela equipe de QA, dando ainda mais confian√ßa no mesmo.</p>
<p>Mas subir ambientes de homologa√ß√£o para cada um dos PRs, automaticamente ou sobre demanda, n√£o √© um problema trivial, envolve subir m√°quinas, garantir que esta rodando a vers√£o atualizada, liberar portas, etc.</p>
<p>Uma forma que encontramos para resolver esse problema √© utilizando um cluster Kubernetes (ou a vers√£o da Red Hat o OpenShift), pois essas a√ß√µes s√£o bem simples de realizar com ele e ainda mais f√°ceis se forem automatizadas.</p>
<p>Agora vou explicar como montar um exemplo simples, um para o GitLab e outro para o GitHub, integrando com o OpenShift da <a href="https://getupcloud.com.br">Getup Cloud</a>.</p>
<p>Sobre uma introdu√ß√£o ao Kubernetes/OpenShift pode ver aqui:</p>
<p><a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/"><strong>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte 1</strong></a></p>
<p>O cliente de linha de comando pode ser baixado em:</p>
<p><a href="https://github.com/openshift/origin/releases"><strong>openshift/origin</strong> origin - Enterprise Kubernetes for Developers</a></p>
<h4 id="gitlab-integrations-ci-registry-e-environments">
	GitLab: Integrations, CI, Registry e Environments
	
		<a href="#gitlab-integrations-ci-registry-e-environments" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/gitlab.png"
		
			width="800" height="202"
		
	/>
	
</figure>

<p>A primeira experiencia que fizemos foi com o <a href="https://gitlab.com">GitLab</a>, principalmente pela integra√ß√£o que ele traz com o Kubernetes, e as outras ferramentas que ele oferece que acabaram cobrindo todo o escopo do problema.</p>
<p>O que queremos montar √© um ambiente por branch/PR que deve ser facilmente criado e destru√≠do. Para demonstrar criei um reposit√≥rio no GitLab com uma aplica√ß√£o bem simples que apenas retorna uma p√°gina est√°tica, mas √© o suficiente para o objetivo.</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/helloworld-view.png"
		
			width="638" height="365"
		
	/>
	
		<figcaption><p>retorno do servi√ßo helloworld</p></figcaption>
	
</figure>

<p>Primeiramente criei a base da aplica√ß√£o usando Docker, a mesma gera uma p√°gina com o conte√∫do acima. O que vale destacar nesse primeiro momento √© que j√° configurei um processo de CI simples:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">build</span>:
  <span style="color:#268bd2">image</span>: docker:latest
  <span style="color:#268bd2">services</span>:
    - docker:dind
  <span style="color:#268bd2">stage</span>: build
  <span style="color:#268bd2">script</span>:
    - docker login -u &#34;gitlab-ci-token&#34; -p &#34;$CI_JOB_TOKEN&#34; $CI_REGISTRY
    - docker build --pull -t &#34;$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34; .
    - docker push &#34;$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34;
    - echo &#34;Pushing image $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34;
  <span style="color:#268bd2">only</span>:
    - branches
</code></pre></div><p class="code-legend">.gitlab-ci.yml</p>
<p>Nesse CI eu construo o cont√™iner da aplica√ß√£o para cada commit feito e guardo no registro do pr√≥prio GitLab por branch, dessa forma tenho uma vers√£o do meu cont√™iner para cada uma das branchs que forem criadas e vou atualizando essas vers√µes automaticamente a cada altera√ß√£o.</p>
<p>Fonte completo at√© aqui:</p>
<p><a href="https://gitlab.com/lucassabreu/k8s-pr-envs/tree/v1"><strong>Files ¬∑ v1 ¬∑ Lucas dos Santos Abreu / k8s-pr-envs</strong></a></p>
<hr>
<p>Nesse momento n√£o tenho nenhum deploy, seja de ambiente de teste, produ√ß√£o ou por branch.</p>
<p>Ent√£o vamos adicionar um processo de deploy no OpenShift para o ambiente de produ√ß√£o e testes, sendo que o ambiente de testes √© atualizado automaticamente para os commits na master e o de produ√ß√£o apenas quando um usu√°rio disparar o deploy.</p>
<p>Para fazer isso primeiramente temos de configurar a integra√ß√£o entre o OpenShift e o GitLab, para isso vamos em <em>Settings</em> &gt; <em>Integrations</em> e procuramos <em>Kubernetes</em> nas op√ß√µes. O GitLab ir√° solicitar algumas informa√ß√µes sobre o ambiente, qual o <strong>Namespace</strong>, o <strong>URL da API</strong> do <strong>Kubernetes</strong> e uma forma de autentica√ß√£o, que pode ser um <strong>Service Token</strong> ou um <strong>CA Bundle</strong>.</p>
<p>Dessa forma vou criar um novo <strong>Namespace</strong>, como fazer isso vai depender do seu vendor de Kubernetes, no caso da <a href="https://getupcloud.com.br">Getup Cloud</a>, basta ir em <a href="https://portal.getupcloud.com/projects">https://portal.getupcloud.com/projects</a> e criar um novo projeto, o nome do projeto ser√° o <strong>Namespace.</strong></p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/dashboard-getup.png"
		
			width="800" height="282"
		
	/>
	
</figure>

<p>Uma vez com o <strong>Namespace</strong> podemos criar um novo <strong>Service Token</strong> para ser usado no CI do GitLab, no caso para criar um Service Token √© necess√°rio criar uma ServiceAccount e dar permiss√µes a mesma, e ent√£o pegar o Service Token dela. O script abaixo realiza essas opera√ß√µes:</p>
<pre>
<b>$ oc login https://api.getupcloud.com:443</b>
Authentication required for https://api.getupcloud.com:443 ...
Username: lucas.s.abreu@gmail.com
Password:
Login successful.
...

<b>$ oc project gitlab-k8s-pr-envs #usar o seu projeto</b>
Now using project "gitlab-k8s-pr-envs" on server ...

<b>$ oc create serviceaccount gitlab</b>
serviceaccount "gitlab" created

<b>$ oc policy add-role-to-user admin \</b>
    system:serviceaccount:gitlab-k8s-pr-envs:gitlab

<b>$ oc describe serviceaccount gitlab</b>
Name:  gitlab
Namespace: gitlab-k8s-pr-envs
Labels:  <none>

Image pull secrets: gitlab-dockercfg-qj9o9

Mountable secrets:  gitlab-token-6ael2
                    gitlab-dockercfg-qj9o9

Tokens:             gitlab-token-6ael2
                    gitlab-token-zkk6u

<b>$ oc describe secret gitlab-token-6ael2</b>
Name:  gitlab-token-6ael2
Namespace: gitlab-k8s-pr-envs
Labels:  <none>
Annotations: kubernetes.io/service-account.name=gitlab
  kubernetes.io/service-account.uid=zzz

Type: kubernetes.io/service-account-token

Data
====
ca.crt:  1066 bytes
namespace: 18 bytes
service-ca.crt: 2182 bytes
token:  <i><b>token-do-openshift-que-estou-ocultando</i></b>
</pre>
<p>Agora que temos o token gerado basta adicionar essas informa√ß√µes no
GitLab.</p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/gitlab-k8s-integration.png"
		
			width="750" height="481"
		
	/>
	
</figure>

<p>Voc√™ pode confirmar se passou os dados corretos com o bot√£o de teste no GitLab.</p>
<p>Certo, agora o GitLab consegue conversar com o OpenShift. Podemos ent√£o alterar nossas regras de CI para criar duas novas etapas: <em>staging</em> e <em>production</em>, que ir√£o realizar o deploy dos nossos ambientes padr√µes, sendo que <em>staging</em> ser√° disparada automaticamente por commits na master e <em>production</em> ficar√° como manual.</p>
<p>O¬†.<code>gitlab-ci.yml</code> ficou como abaixo (j√° usando a integra√ß√£o com OpenShift):</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">stages</span>:
  - build
  - staging
  - production

<span style="color:#268bd2">variables</span>:
  <span style="color:#268bd2">KUBE_DOMAIN</span>: getup.io

<span style="color:#268bd2">build</span>:
  <span style="color:#268bd2">stage</span>: build
  <span style="color:#268bd2">image</span>: docker:latest
  <span style="color:#268bd2">services</span>:
    - docker:dind
  <span style="color:#268bd2">script</span>:
    - docker login -u &#34;gitlab-ci-token&#34; -p &#34;$CI_JOB_TOKEN&#34; $CI_REGISTRY
    - docker build --pull -t &#34;$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34; .
    - docker push &#34;$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34;
    - echo &#34;Pushing image $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME&#34;
  <span style="color:#268bd2">only</span>:
    - branches

<span style="color:#268bd2">staging</span>:
  <span style="color:#268bd2">stage</span>: staging
  <span style="color:#268bd2">image</span>: lucassabreu/openshift-k8s-cli:latest
  <span style="color:#268bd2">variables</span>:
    <span style="color:#268bd2">CI_ENVIRONMENT_URL</span>: http://$CI_PROJECT_NAME-staging.$KUBE_DOMAIN
  <span style="color:#268bd2">environment</span>:
    <span style="color:#268bd2">name</span>: staging
    <span style="color:#268bd2">url</span>: http://$CI_PROJECT_NAME-staging.$KUBE_DOMAIN
  <span style="color:#268bd2">script</span>:
    - k8s/deploy
  <span style="color:#268bd2">only</span>:
    - master

<span style="color:#268bd2">production</span>:
  <span style="color:#268bd2">stage</span>: production
  <span style="color:#268bd2">image</span>: lucassabreu/openshift-k8s-cli:latest
  <span style="color:#268bd2">variables</span>:
    <span style="color:#268bd2">CI_ENVIRONMENT_URL</span>: http://$CI_PROJECT_NAME.$KUBE_DOMAIN
  <span style="color:#268bd2">environment</span>:
    <span style="color:#268bd2">name</span>: production
    <span style="color:#268bd2">url</span>: http://$CI_PROJECT_NAME.$KUBE_DOMAIN
  <span style="color:#268bd2">when</span>: manual
  <span style="color:#268bd2">script</span>:
    - k8s/deploy
  <span style="color:#268bd2">only</span>:
    - master
</code></pre></div><p class="code-legend">.gitlab-ci.yml (v2)</p>
<p>As mudan√ßa s√£o os novos stages <code>staging</code> e <code>production</code>; as vari√°veis novas <code>KUBE_DOMAIN</code> e <code>CI_ENVIRONMENT_URL</code>; e o script <code>k8s/deploy</code>. Vamos por partes.</p>
<p>A vari√°vel <code>KUBE_DOMAIN</code> vai ajudar a deixar o nosso processo de deploy mais simples, basicamente n√≥s colocamos nela o dom√≠nio base que o OpenShift usa para expor as rotas dele, no caso da Getup seria &ldquo;<em>getup.io</em>&rdquo;. A <code>CI_ENVIRONMENT_URL</code> √© completar a <code>KUBE_DOMAIN</code> e serve para informar o <code>k8s/deploy</code> qual endere√ßo ele deve expor o ambiente, ele deve sempre terminar com o <code>KUBE_DOMAIN</code> e deve ser igual a <code>url</code> da chave <code>environment</code>, pois √© por essa chave que o GitLab sabe onde os ambientes est√£o expostos.</p>
<p>As etapas de <code>staging</code> e <code>production</code> ir√£o fazer o deploy dos nossos ambientes e como comentei antes o ambiente de <em>staging</em> ter√° deploy autom√°tico para todo commit na master, enquanto <em>production</em> ir√° esperar uma a√ß√£o do usu√°rio. No mais as duas etapas s√£o iguais mudando apenas a URL que est√£o sendo expostas. Estou usando a imagem <code>lucassabreu/openshift-k8s-cli</code> que √© basicamente um <code>ubuntu</code> com o <code>oc</code> instalado.</p>
<p>O script <code>k8s/deploy</code> est√° abaixo e ele basicamente se autentica contra a API do OpenShift usando o <em>Service Token</em> que criamos antes, destr√≥i a aplica√ß√£o antiga e executa o deploy de uma nova.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#719e07">#!/bin/bash
</span><span style="color:#719e07"></span>
oc login <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$KUBE_URL</span><span style="color:#2aa198">&#34;</span> --token <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$KUBE_TOKEN</span><span style="color:#2aa198">&#34;</span>
oc project <span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$KUBE_NAMESPACE</span><span style="color:#2aa198">&#34;</span>

<span style="color:#268bd2">HOSTNAME</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$CI_ENVIRONMENT_URL</span><span style="color:#2aa198">&#34;</span>

<span style="color:#586e75"># remove protocol from URL</span>
<span style="color:#268bd2">HOSTNAME</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#2aa198">${</span><span style="color:#268bd2">HOSTNAME</span>/<span style="color:#cb4b16">\h</span><span style="color:#268bd2">ttp</span>:<span style="color:#cb4b16">\/\/</span>/<span style="color:#2aa198">}</span><span style="color:#2aa198">&#34;</span>
<span style="color:#268bd2">HOSTNAME</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#2aa198">${</span><span style="color:#268bd2">HOSTNAME</span>/<span style="color:#cb4b16">\h</span><span style="color:#268bd2">ttp</span>:<span style="color:#cb4b16">\/\/</span>/<span style="color:#2aa198">}</span><span style="color:#2aa198">&#34;</span>

<span style="color:#268bd2">IMAGE_TAG</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$CI_REGISTRY_IMAGE</span><span style="color:#2aa198">:</span><span style="color:#268bd2">$CI_BUILD_REF_NAME</span><span style="color:#2aa198">&#34;</span>
<span style="color:#268bd2">ENV</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$CI_ENVIRONMENT_SLUG</span><span style="color:#2aa198">&#34;</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Deleting old application...&#34;</span>
oc delete all -l <span style="color:#2aa198">&#34;app=</span><span style="color:#268bd2">$CI_ENVIRONMENT_SLUG</span><span style="color:#2aa198">&#34;</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Deploying image </span><span style="color:#268bd2">$IMAGE_TAG</span><span style="color:#2aa198"> to env </span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198"> at </span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">...&#34;</span>

sed <span style="color:#2aa198">&#34;
</span><span style="color:#2aa198">  s|__HOSTNAME__|</span><span style="color:#268bd2">$HOSTNAME</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">  s|__ENV__|</span><span style="color:#268bd2">$ENV</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">  s|__IMAGE_TAG__|</span><span style="color:#268bd2">$IMAGE_TAG</span><span style="color:#2aa198">|;
</span><span style="color:#2aa198">  &#34;</span> k8s/full.yml | oc apply -f -
<span style="color:#719e07">if</span> <span style="color:#719e07">[</span> <span style="color:#268bd2">$?</span> !<span style="color:#719e07">=</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">]</span>; <span style="color:#719e07">then</span>
  <span style="color:#b58900">exit</span> <span style="color:#2aa198">1</span>
<span style="color:#719e07">fi</span>

<span style="color:#b58900">echo</span> <span style="color:#2aa198">&#34;&gt;&gt; Deployed to </span><span style="color:#268bd2">$CI_ENVIRONMENT_URL</span><span style="color:#2aa198">&#34;</span>
</code></pre></div><p class="code-legend">k8s/deploy</p>
<p>Vale ressaltar que √© importante marcar os componentes do ambiente com <code>app=$CI_ENVIRONMENT_SLUG</code>, pois √© assim que o GitLab consegue encontrar eles e lhe retornar status sobre eles.</p>
<p>Tamb√©m estou usando um truque de &ldquo;templating&rdquo; com o YAML que define os ambientes para poder inserir as vari√°veis de cada ambiente nele. Existem outras ferramentas mais avan√ßadas como o <a href="https://github.com/kubernetes/helm">Helm</a>, mas para o meu exemplo templating com <code>sed</code> √© o suficiente.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: hw-dpl-__ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">app</span>: __ENV__
        <span style="color:#268bd2">name</span>: hw-pod
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
      - <span style="color:#268bd2">name</span>: hw-container
        <span style="color:#268bd2">image</span>: __IMAGE_TAG__
        <span style="color:#268bd2">imagePullPolicy</span>: Always
        <span style="color:#268bd2">ports</span>:
        - <span style="color:#268bd2">name</span>: web-port
          <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">8080</span>
---
<span style="color:#268bd2">apiVersion</span>: <span style="color:#2aa198">&#34;v1&#34;</span>
<span style="color:#268bd2">kind</span>: Service
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: hw-src-__ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">ports</span>:
    - <span style="color:#268bd2">port</span>: <span style="color:#2aa198">80</span>
      <span style="color:#268bd2">targetPort</span>: <span style="color:#2aa198">&#34;web-port&#34;</span>
      <span style="color:#268bd2">protocol</span>: TCP
  <span style="color:#268bd2">selector</span>:
    <span style="color:#268bd2">name</span>: hw-pod
    <span style="color:#268bd2">app</span>: __ENV__
---
<span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: Route
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: __ENV__
  <span style="color:#268bd2">labels</span>:
    <span style="color:#268bd2">app</span>: __ENV__
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">host</span>: __HOSTNAME__
  <span style="color:#268bd2">to</span>:
    <span style="color:#268bd2">kind</span>: Service
    <span style="color:#268bd2">name</span>: hw-src-__ENV__
</code></pre></div><p class="code-legend">k8s/full.yml</p>
<p>Agora, depois que do commit das altera√ß√µes, o GitLab faz o <em>build</em>, o deploy da <em>staging</em> e <em>production</em> (manual); podemos ver na √°rea <em>Environments</em> do GitLab que os ambientes est√£o rodando, ele inclusive traz alguns comandos para facilitar a vida: link para a URL do ambiente, terminal dentro do Pod e op√ß√£o de Re-deploy.</p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/gilab-envs.png"
		
			width="1000" height="301"
		
	/>
	
</figure>

<p>Fonte completo at√© agora:</p>
<p><a href="https://gitlab.com/lucassabreu/k8s-pr-envs/tree/v2"><strong>Files ¬∑ v2 ¬∑ Lucas dos Santos Abreu / k8s-pr-envs</strong></a></p>
<hr>
<p>Agora que temos o <em>build</em> da nossa aplica√ß√£o e um deploy automatizado, vamos adicionar a fun√ß√£o de deploy por branch.</p>
<p>Basicamente precisamos de duas novas etapas no nosso CI, uma para subir o ambiente para uma branch e outro para destruir esse ambiente para evitar consumir recursos sem necessidade.</p>
<p>Para isso fiz as seguintes altera√ß√µes nos¬†<code>.gitlab-ci.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">stages</span>:
  - build
  - review
  - staging
  - production
  - cleanup

<span style="color:#268bd2">review</span>:
  <span style="color:#268bd2">stage</span>: review
  <span style="color:#268bd2">image</span>: lucassabreu/openshift-k8s-cli:latest
  <span style="color:#268bd2">variables</span>:
    <span style="color:#268bd2">CI_ENVIRONMENT_URL</span>: http://$CI_PROJECT_NAME-$CI_ENVIRONMENT_SLUG.$KUBE_DOMAIN
  <span style="color:#268bd2">environment</span>:
    <span style="color:#268bd2">name</span>: r/$CI_COMMIT_REF_NAME
    <span style="color:#268bd2">url</span>: http://$CI_PROJECT_NAME-$CI_ENVIRONMENT_SLUG.$KUBE_DOMAIN
    <span style="color:#268bd2">on_stop</span>: stop_review
  <span style="color:#268bd2">script</span>:
    - k8s/deploy
  <span style="color:#268bd2">only</span>:
    - branches
  <span style="color:#268bd2">except</span>:
    - master

<span style="color:#268bd2">stop_review</span>:
  <span style="color:#268bd2">stage</span>: cleanup
  <span style="color:#268bd2">image</span>: lucassabreu/openshift-k8s-cli:latest
  <span style="color:#268bd2">environment</span>:
    <span style="color:#268bd2">name</span>: r/$CI_COMMIT_REF_NAME
    <span style="color:#268bd2">action</span>: stop
  <span style="color:#268bd2">when</span>: manual
  <span style="color:#268bd2">variables</span>:
    <span style="color:#268bd2">GIT_STRATEGY</span>: none
  <span style="color:#268bd2">script</span>:
    - oc login &#34;$KUBE_URL&#34; --token &#34;$KUBE_TOKEN&#34;
    - oc project &#34;$KUBE_NAMESPACE&#34;
    - oc delete deployments -l &#34;app=$CI_ENVIRONMENT_SLUG&#34;
    - oc delete all -l &#34;app=$CI_ENVIRONMENT_SLUG&#34;
  <span style="color:#268bd2">only</span>:
    - branches
  <span style="color:#268bd2">except</span>:
    - master

[...]
</code></pre></div><p class="code-legend">.gitlab-ci.yml (v3)</p>
<p>Basicamente adicionei as duas novas etapas, <code>review</code> basicamente faz a mesma coisa que <code>staging</code>, mas usa um nome de ambiente din√¢mico baseado na branch; e tem um <code>enviroment:on_stop</code> que basicamente indica o que fazer quando a branch for removida.</p>
<p>Na etapa <code>stop_review</code> executo alguns comandos para eliminar o ambiente quando for chamada, √© importante deixar essa como <code>manual</code> para que ela n√£o apague sozinha o ambiente quando terminar as outras etapas.</p>
<p>Os comandos da etapa <code>stop_review</code> precisam estar definidos diretamente no¬†<code>.gitlab-ci.yml</code>, pois quando essa etapa for executada √© poss√≠vel que a branch e commits dela n√£o existam mais, √© tamb√©m por esse motivo que informamos a vari√°vel <code>GIT_STRATEGY</code> como <code>NO</code> evitando que sequer seja checado se a branch/commit de origem existem.</p>
<p>Agora quando crio uma nova branch automaticamente √© criado um novo ambiente para a mesma no OpenShift.</p>
<p>Para testar criei a branch <code>a-change</code> e fiz a seguinte altera√ß√£o:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">   &lt;img id=&#34;logo&#34; src=&#34;logo.svg&#34;
     alt=&#34;CodeRocker&#34; title=&#34;CodeRocker&#34; /&gt;
   &lt;h1&gt;Hello World !&lt;/h1&gt;
<span style="color:#719e07">+  &lt;h2&gt;(with a change)&lt;/h2&gt;
</span><span style="color:#719e07"></span> &lt;/body&gt;
 &lt;/html&gt;
</code></pre></div><p class="code-legend">public/index.html (pr)</p>
<p>Assim que dei o <code>git push</code> come√ßou o deploy do novo ambiente <code>r/a-change</code>, logo que terminou pude verificar na √°rea de ambientes do GitLab que estava rodando, e tem as mesmas opera√ß√µes dispon√≠veis que os outros, mais a op√ß√£o de parada (<code>stop_review</code>):</p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/branch-env.png"
		
			width="1000" height="145"
		
	/>
	
</figure>

<p>J√° rodando as altera√ß√µes:</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/ambientes-por-branch-com-openshift-next-gen/a-change.png"
		
			width="612" height="343"
		
	/>
	
</figure>

<p>Fontes com essas altera√ß√µes em:</p>
<p><a href="https://gitlab.com/lucassabreu/k8s-pr-envs/tree/v3"><strong>Files ¬∑ v3 ¬∑ Lucas dos Santos Abreu / k8s-pr-envs</strong></a></p>
<hr>
<p>Ap√≥s essas altera√ß√µes podemos implementar a regra de merge apenas ap√≥s testes pela equipe de QA, sem interfer√™ncia de outras atividades que foram aplicadas no meio do caminho e permitindo um controle melhor sobre o que esta pronto para ir para a produ√ß√£o.</p>
<hr>
<p>A postagem acabou ficando bem grande apenas para falar do processo no GitLab, por isso vou criar um segundo post sobre como fazer isso no GitHub, abaixo esta o link para ele:</p>
<p><a href="/post/ambientes-por-branch-com-openshift-next-gen-usando-github"><strong>Ambientes por Branch com OpenShift Next Gen usando GitHub</strong></a></p>]]></content:encoded></item><item><title>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†4</title><link>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4/</link><pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4/</guid><description>Para completar a jornada vamos ver como o Kubernetes lida com dados sens√≠veis dentro da plataforma</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png"
		
			width="1000" height="165"
		
	/>
	
</figure>

<p>Este post √© a quarta parte de uma s√©rie sobre o b√°sico necess√°rio para usar o Kubernetes, caso voc√™ n√£o tenha lido o post anterior recomendo l√™-lo e depois voltar aqui para n√£o ficar perdido.</p>
<ul>
<li>Parte 1‚Ää-‚ÄäConceitos B√°sicos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1">clique aqui</a></li>
<li>Parte 2‚Ää-‚ÄäConstruindo o Ambiente: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2">clique aqui</a></li>
<li>Parte 3‚Ää-‚ÄäVolumes Persistentes: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3">clique aqui</a></li>
</ul>
<hr>
<p>Como citei no <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3">post anterior</a> ainda existe um ponto de desconforto no ambiente, que √© o fato das senhas e usu√°rios estarem expostos diretamente nas configura√ß√µes. O Kubernetes oferece uma solu√ß√£o para esse problema os <a href="https://kubernetes.io/docs/user-guide/secrets/"><strong>Secrets</strong></a>.</p>
<p>E agora irei mostrar como adicion√°-los ao projeto.</p>
<p>Caso n√£o tenha mais os fontes at√© o estado do post anterior, ou prefira acompanhar o meu andamento, pode pode peg√°-los aqui: <a href="https://github.com/lucassabreu/openshift-next-gen/tree/v2">https://github.com/lucassabreu/openshift-next-gen/tree/v2</a>; ou executar:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone -b v2 <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>    https://github.com/lucassabreu/openshift-next-gen.git
</code></pre></div><hr>
<h4 id="secrets">
	Secrets
	
		<a href="#secrets" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Existem algumas formas de criar e usar os mesmos, cri√°-los diretamente de arquivos, ou usando configura√ß√µes, e exp√¥-los aos cont√™ineres usando volumes ou vari√°veis de ambiente.</p>
<p>Para essa aplica√ß√£o vou utilizar um YAML para definir um Secret e vou modificar os Pods para alimentarem as vari√°veis de ambiente com eles. A estrutura b√°sica do Secret √© como segue:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: Secret
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: mysql-secrets
<span style="color:#268bd2">type</span>: Opaque
<span style="color:#268bd2">data</span>:
  <span style="color:#268bd2">mysql-root-password</span>: &lt;hash base64&gt;
  <span style="color:#268bd2">mysql-user</span>: &lt;hash base64&gt;
  <span style="color:#268bd2">mysql-password</span>: &lt;hash base64&gt;
  <span style="color:#268bd2">mysql-database-connection</span>: &lt;hash base64&gt;
</code></pre></div><p>Nele estou criando o Secret <code>mysql-secrets</code> e definindo quatro chaves que representam as tr√™s vari√°veis do MySQL e uma do servidor HTTP. No lugar do <code>&lt;hash base64&gt;</code> deve ir o conte√∫do do segredo em Base 64, que pode ser gerado usando o comando <code>echo -n &quot;meusegredo&quot; | base64 -w0</code>.</p>
<p>Eu n√£o gostei muito da ideia de guardar o Base 64 dentro da defini√ß√£o do Secret, ent√£o fiz a seguinte modifica√ß√£o no meu <code>mysql-secrets.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: Secret
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: mysql-secrets
<span style="color:#268bd2">type</span>: Opaque
<span style="color:#268bd2">data</span>:
  <span style="color:#268bd2">mysql-root-password</span>: %MYSQL_ROOT_PASSWORD
  <span style="color:#268bd2">mysql-user</span>: %MYSQL_USER
  <span style="color:#268bd2">mysql-password</span>: %MYSQL_PASSWORD
  <span style="color:#268bd2">mysql-database-connection</span>: %DATABASE_CONNECTION
</code></pre></div><p>E quando vou aplicar o Secret no Kubernetes uso este script:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#268bd2">MYSQL_ROOT_PASSWORD</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span>&lt; /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c<span style="color:#2aa198">${</span><span style="color:#268bd2">1</span><span style="color:#719e07">:-</span><span style="color:#268bd2">32</span><span style="color:#2aa198">}</span><span style="color:#719e07">)</span>
<span style="color:#268bd2">B64_MYSQL_ROOT_PASSWORD</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">echo</span> -n <span style="color:#268bd2">$MYSQL_ROOT_PASSWORD</span> | base64 -w0<span style="color:#719e07">)</span>
<span style="color:#268bd2">B64_DATABASE_USER</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">echo</span> -n <span style="color:#268bd2">$DATABASE_USER</span> | base64 -w0<span style="color:#719e07">)</span>
<span style="color:#268bd2">B64_DATABASE_PASSWORD</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">echo</span> -n <span style="color:#268bd2">$DATABASE_PASSWORD</span> | base64 -w0<span style="color:#719e07">)</span>
<span style="color:#268bd2">B64_DATABASE_CONNECTION</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">echo</span> -n <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>    <span style="color:#2aa198">&#34;mysql://</span><span style="color:#268bd2">$DATABASE_USER</span><span style="color:#2aa198">:</span><span style="color:#268bd2">$DATABASE_PASSWORD</span><span style="color:#2aa198">@db-service:3306/appointments&#34;</span> <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>    | base64 -w0<span style="color:#719e07">)</span>

sed <span style="color:#2aa198">&#34;\
</span><span style="color:#2aa198">  s|%MYSQL_ROOT_PASSWORD|</span><span style="color:#268bd2">$B64_MYSQL_ROOT_PASSWORD</span><span style="color:#2aa198">|;\
</span><span style="color:#2aa198">  s|%MYSQL_USER|</span><span style="color:#268bd2">$B64_DATABASE_USER</span><span style="color:#2aa198">|;\
</span><span style="color:#2aa198">  s|%MYSQL_PASSWORD|</span><span style="color:#268bd2">$B64_DATABASE_PASSWORD</span><span style="color:#2aa198">|;\
</span><span style="color:#2aa198">  s|%DATABASE_CONNECTION|</span><span style="color:#268bd2">$B64_DATABASE_CONNECTION</span><span style="color:#2aa198">|&#34;</span> <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  mysql-secrets.yml | oc apply -f -
</code></pre></div><p>Esse script cria uma senha aleat√≥ria para o root e usa duas vari√°veis de ambiente para definir o usu√°rio e senha do MySQL, faz o Base 64 deles, injeta eles no arquivo via <code>sed</code> no Secret e aplica no Kubernetes com <code>oc apply -f -</code> que ir√° ler a sa√≠da do <code>sed</code> e aplic√°-la. Na hora de executar fica assim:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ <span style="color:#b58900">export</span> <span style="color:#268bd2">DATABASE_USER</span><span style="color:#719e07">=</span>appoint
$ <span style="color:#b58900">export</span> <span style="color:#268bd2">DATABASE_PASSWORD</span><span style="color:#719e07">=</span><span style="color:#2aa198">123</span>
$ ./env-set-oc.sh
secret <span style="color:#2aa198">&#34;mysql-secrets&#34;</span> configured
</code></pre></div><p>Altero os Deployments para considerarem o Secret que criei:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-deployment&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-pod&#34;</span>
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db&#34;</span>
          <span style="color:#268bd2">image</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-mysql-test&#34;</span>
          <span style="color:#268bd2">ports</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-port&#34;</span>
              <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">3306</span>
          <span style="color:#268bd2">env</span>:
            - <span style="color:#268bd2">name</span>: MYSQL_DATABASE
              <span style="color:#268bd2">value</span>: appointments
            - <span style="color:#268bd2">name</span>: MYSQL_ROOT_PASSWORD
              <span style="color:#268bd2">valueFrom</span>:
                <span style="color:#268bd2">secretKeyRef</span>:
                  <span style="color:#268bd2">name</span>: mysql-secrets
                  <span style="color:#268bd2">key</span>: mysql-root-password
            - <span style="color:#268bd2">name</span>: MYSQL_USER
              <span style="color:#268bd2">valueFrom</span>:
                <span style="color:#268bd2">secretKeyRef</span>:
                  <span style="color:#268bd2">name</span>: mysql-secrets
                  <span style="color:#268bd2">key</span>: mysql-user
            - <span style="color:#268bd2">name</span>: MYSQL_PASSWORD
              <span style="color:#268bd2">valueFrom</span>:
                <span style="color:#268bd2">secretKeyRef</span>:
                  <span style="color:#268bd2">name</span>: mysql-secrets
                  <span style="color:#268bd2">key</span>: mysql-password
          <span style="color:#268bd2">volumeMounts</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-persistent-volume&#34;</span>
              <span style="color:#268bd2">mountPath</span>: <span style="color:#2aa198">&#34;/var/lib/mysql&#34;</span>
      <span style="color:#268bd2">volumes</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-persistent-volume&#34;</span>
          <span style="color:#268bd2">persistentVolumeClaim</span>:
            <span style="color:#268bd2">claimName</span>: mysql-pv-claim
</code></pre></div><p><small><center>db-deployment.yml</center></small></p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-deployment&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-pod&#34;</span>
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node&#34;</span>
          <span style="color:#268bd2">image</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-app-test&#34;</span>
          <span style="color:#268bd2">ports</span>:
            - <span style="color:#268bd2">name</span>: node-port
              <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">8080</span>
              <span style="color:#268bd2">protocol</span>: TCP
          <span style="color:#268bd2">env</span>:
            - <span style="color:#268bd2">name</span>: DATABASE_CONNECTION
              <span style="color:#268bd2">valueFrom</span>:
                <span style="color:#268bd2">secretKeyRef</span>:
                  <span style="color:#268bd2">name</span>: mysql-secrets
                  <span style="color:#268bd2">key</span>: mysql-database-connection
</code></pre></div><p><small><center>node-deployment.yml</center></small></p>
<p>A altera√ß√£o consiste de trocar a chave <code>value</code> das vari√°veis por <code>valueFrom</code> e apontar para as chaves corretas dentro do Secret.</p>
<p>Depois que aplica as mudan√ßas os Deployments v√£o identific√°-las e trocar os Pods por novos. E passaram a utilizar os Secrets informado nas vari√°veis para eles.</p>
<hr>
<p>Ao final dessa s√©ria, a conclus√£o que posso chegar √© que o Kubernetes exige um conjunto razoavelmente grande de configura√ß√µes para podermos servir uma aplica√ß√£o, mas s√£o arquivos simples de se entender e muito bem <a href="https://kubernetes.io/docs/reference/">documentados</a> o que facilitou bastante o processo, e n√£o me fez sentir o peso dessa quantidade.</p>]]></content:encoded></item><item><title>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†3</title><link>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/</link><pubDate>Thu, 09 Mar 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/</guid><description>Agora que sabemos os conceitos por traz do Kubernetes e vimos um exemplo b√°sico de utiliza√ß√£o, vamos ver como lidamos com cont√™iners que precisam de persist√™ncia.</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png"
		
			width="1000" height="165"
		
	/>
	
</figure>

<p>Este post √© a terceira parte de uma s√©rie sobre o b√°sico necess√°rio para
usar o Kubernetes, caso voc√™ n√£o tenha lido o post anterior recomendo
l√™-lo e depois voltar aqui para n√£o ficar perdido.</p>
<ul>
<li>Parte 1‚Ää-‚ÄäConceitos B√°sicos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1">clique aqui</a></li>
<li>Parte 2‚Ää-‚ÄäConstruindo o Ambiente: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2">clique aqui</a></li>
<li>Parte 4‚Ää-‚ÄäSegredos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4">clique aqui</a></li>
</ul>
<hr>
<p>Como comentei no <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2">post anterior</a> existem alguns problemas no ambiente que constru√≠, e o princ√≠pial deles √© que os Pods n√£o totalmente ef√™meros, ou seja, se eu adicionar novos dados nele, no momento que o Pod fosse destru√≠do os dados iriam junto e sem backup¬†!</p>
<p>E agora iremos tratar esse primeiro problema. Caso n√£o tenha mais os fontes at√© o estado do post anterior, ou prefira acompanhar o meu andamento, pode pode peg√°-los aqui: <a href="https://github.com/lucassabreu/openshift-next-gen/tree/v1">https://github.com/lucassabreu/openshift-next-gen/tree/v1</a>; ou executar:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone -b v1 <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>    https://github.com/lucassabreu/openshift-next-gen.git
</code></pre></div><hr>
<h4 id="a297">
	Volumes Persistentes
	
		<a href="#a297" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Podemos testar esse problema conectando no Pod e adicionando alguns dados e ent√£o destruindo ele para ver o efeito. Vou adicionar um registro sobre para Homens no S√°bado, pois √© um dia sem nenhuma informa√ß√£o e facilita a visualiza√ß√£o.</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/male-chart-before.png"
		
			width="494" height="350"
		
	/>
	
		<figcaption><p>Antes... sem¬†dados</p></figcaption>
	
</figure>

<p>Para acessar o Pod usa-se o comando <code>oc rsh &lt;pod-name&gt;</code>, e para encontrar o nome do Pod posso usar o comando <code>oc get pods -l &lt;selector&gt;</code>, ent√£o √© s√≥ acessar o MySQL e inserir os dados:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ oc get pods -l <span style="color:#268bd2">name</span><span style="color:#719e07">=</span>db-pod
NAME                             READY     STATUS    RESTARTS   AGE
db-deployment-3618823556-zrje2   1/1       Running   <span style="color:#2aa198">0</span>          14m
$ oc rsh db-deployment-3618823556-zrje2 bash
&lt;dentro cont√™iner&gt;:/$ mysql -u<span style="color:#268bd2">$MYSQL_USER</span> -p<span style="color:#268bd2">$MYSQL_PASSWORD</span> appointments
mysql&gt; insert into appointments values<span style="color:#719e07">(</span>21, <span style="color:#2aa198">&#39;M&#39;</span>, <span style="color:#2aa198">&#39;2017-03-05&#39;</span>, <span style="color:#2aa198">&#39;Sunday&#39;</span>, 1, null<span style="color:#719e07">)</span>;
Query OK, <span style="color:#2aa198">1</span> row affected <span style="color:#719e07">(</span>0.00 sec<span style="color:#719e07">)</span>
</code></pre></div><p>Entrando novamente na aplica√ß√£o e indo em &ldquo;Sunday&rdquo;, tenho um gr√°fico com dados para os Homens.</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/male-chart-changed.png"
		
			width="435" height="348"
		
	/>
	
		<figcaption><p>isso se o seu cont√™iner n√£o morrer no¬†caminho</p></figcaption>
	
</figure>

<p>Para concluir o teste, basta apagar o Pod com <code>oc delete pods -l name=db-pod</code> ou <code>oc delete pod db-deployment-xyz</code>, esperar o Pod ser recriado e ent√£o ver que as altera√ß√µes nos dados se foram:</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/male-chart-before.png"
		
			width="494" height="350"
		
	/>
	
		<figcaption><p>:&#39;(</p></figcaption>
	
</figure>

<p>Para resolver esse problema o Kubernetes possui os <a href="https://kubernetes.io/docs/user-guide/persistent-volumes/"><strong>Persistent Volume Claims (PVC)</strong></a> que permitem definir volumes que existem fora do ciclo de vida de um Pod, ou seja, mesmo que todos os Pods sejam destru√≠dos, o PVC ir√° manter os dados em si.</p>
<p>Podemos utilizar v√°rios tipos de volumes em um PVC para armazenar os dados, no caso do OpenShift o padr√£o √© <a href="https://kubernetes.io/docs/user-guide/persistent-volumes/#aws">EBS</a>, que s√£o volumes armazenados dentro do <a href="https://aws.amazon.com/">AWS da Amazon</a>, mas existe a op√ß√£o de usar volumes do Google Cloud, do Azure, Locais, etc; no Kubernetes.</p>
<p>Mas no momento o OpenShift esta ofertando apenas o EBS. Abaixo esta a defini√ß√£o do PVC:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: PersistentVolumeClaim
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: mysql-pv-claim
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">accessModes</span>:
    - ReadWriteOnce
  <span style="color:#268bd2">resources</span>:
    <span style="color:#268bd2">requests</span>:
      <span style="color:#268bd2">storage</span>: 1Gi
</code></pre></div><p>Depois de um momento o OpenShift ir√° criar um volume e disponibiliz√°-lo, agora √© preciso vincular ele com os <code>db-pods</code>, para isso basta alterar os volumes no <code>db-deployment</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-deployment&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-pod&#34;</span>
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db&#34;</span>
          <span style="color:#268bd2">image</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-mysql-test&#34;</span>
          <span style="color:#268bd2">ports</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-port&#34;</span>
              <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">3306</span>
          <span style="color:#268bd2">env</span>:
            - <span style="color:#268bd2">name</span>: MYSQL_DATABASE
              <span style="color:#268bd2">value</span>: appointments
            - <span style="color:#268bd2">name</span>: MYSQL_ROOT_PASSWORD
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;root&#34;</span>
            - <span style="color:#268bd2">name</span>: MYSQL_USER
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;appoint&#34;</span>
            - <span style="color:#268bd2">name</span>: MYSQL_PASSWORD
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;123&#34;</span>
          <span style="color:#268bd2">volumeMounts</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-persistent-volume&#34;</span> <span style="color:#586e75"># mudou aqui</span>
              <span style="color:#268bd2">mountPath</span>: <span style="color:#2aa198">&#34;/var/lib/mysql&#34;</span>
      <span style="color:#268bd2">volumes</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-persistent-volume&#34;</span> <span style="color:#586e75"># e aqui</span>
          <span style="color:#268bd2">persistentVolumeClaim</span>:
            <span style="color:#268bd2">claimName</span>: mysql-pv-claim
</code></pre></div><p>Duas coisas foram alteradas no <code>db-deployment</code>:</p>
<ul>
<li>O nome do volume mudou, isso √© necess√°rio porque estamos fazendo uma mudan√ßa de tipo de volume, e o Deployment n√£o consegue alterar o tipo, mas se temos um novo, ent√£o tudo bem.</li>
<li>Adicionei a tag <code>persistentVolumeClaim</code> no volume novo e apontei para o PVC que criei agora a pouco.</li>
</ul>
<p>Executo o comando <code>oc apply -f db-deployment.yml</code> e o Deployment ir√° destruir os Pods antigos e criar novos usando o PVC.</p>
<p>Agora se replicarmos os comandos de para incluir registros e destruir o Pod do MySQL, quando o Deployment recriar o Pod ele manter√° os dados.</p>
<hr>
<p>Outro ponto que esta desconfort√°vel no meu ambiente √© o fato das senhas e usu√°rios estarem expostas diretamente nas configura√ß√µes. O Kubernetes oferece uma solu√ß√£o para esse problema, que irei abordar no pr√≥ximo post.</p>
<p>Pr√≥ximo Post: <a href="/post/um-ambiente-usando-kubernetes-e-openshift-parte-4/">clique aqui</a></p>]]></content:encoded></item><item><title>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†2</title><link>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/</link><pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/</guid><description>Uma vez que entendemos os conceitos b√°sicos do Kubernetes na postagem anterior, vamos para uma demonstra√ß√£o de como utiliz√°-lo para montar uma aplica√ß√£o simples</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png"
		
			width="1000" height="165"
		
	/>
	
</figure>

<p>Este post √© parte de uma s√©rie sobre o b√°sico necess√°rio para usar o Kubernetes, caso voc√™ n√£o tenha lido os post anteriores recomendo l√™-los e depois voltar aqui para n√£o ficar perdido.</p>
<ul>
<li>Parte 1‚Ää-‚ÄäConceitos B√°sicos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1">clique aqui</a></li>
<li>Parte 3‚Ää-‚ÄäVolumes Persistentes: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3">clique aqui</a></li>
<li>Parte 4‚Ää-‚ÄäSegredos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4">clique aqui</a></li>
</ul>
<hr>
<p>Conhecendo os componentes b√°sicos explicados no <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1">post anterior</a> posso preparar a aplica√ß√£o que mostrei para o Kubernetes.</p>
<p>O primeiro passo √© definir quais s√£o os Pods do meu cluster.</p>
<p>Embora o primeiro impulso seja colocar cada um dos cont√™ineres em um Pod distinto e seguir em frente, esse n√£o √© necessariamente a melhor forma de defini-los. Por exemplo, em situa√ß√£o certos cont√™ineres tem o mesmo objetivo, ou dependem muito um do outro √© uma boa ideia mant√™-los juntos.</p>
<p>Mas para a minha aplica√ß√£o faz mais sentido um Pod por cont√™iner, um para o servidor HTTP e outro para o banco de dados.</p>
<p>Como n√£o √© uma boa ideia simplesmente definir um Pod diretamente, criei dois Deployments o <code>node-deployment</code> e o <code>db-deployment</code>.</p>
<p><em>No momento da escrita desse post os Deployments ainda estavam marcados como uma vers√£o beta, mas j√° s√£o bastante usados, ent√£o √© confi√°vel.</em></p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-deployment&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-pod&#34;</span>
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db&#34;</span>
          <span style="color:#268bd2">image</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-mysql-test&#34;</span>
          <span style="color:#268bd2">ports</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-port&#34;</span>
              <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">3306</span>
          <span style="color:#268bd2">env</span>:
            - <span style="color:#268bd2">name</span>: MYSQL_DATABASE
              <span style="color:#268bd2">value</span>: appointments
            - <span style="color:#268bd2">name</span>: MYSQL_ROOT_PASSWORD
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;root&#34;</span>
            - <span style="color:#268bd2">name</span>: MYSQL_USER
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;appoint&#34;</span>
            - <span style="color:#268bd2">name</span>: MYSQL_PASSWORD
              <span style="color:#268bd2">value</span>: <span style="color:#2aa198">&#34;123&#34;</span>
          <span style="color:#268bd2">volumeMounts</span>:
            - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-volume&#34;</span>
              <span style="color:#268bd2">mountPath</span>: <span style="color:#2aa198">&#34;/var/lib/mysql&#34;</span>
      <span style="color:#268bd2">volumes</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;mysql-volume&#34;</span>
</code></pre></div><p>O primeiro Deployment √© para o <code>db-deployment</code>. Os arquivos de configura√ß√£o s√£o simples de ler, sempre come√ßamos o arquivo dizendo o tipo de objeto que ser√° criado, o <code>metadata</code> e definimos as <code>specs</code> (que variam para cada tipo de componente).</p>
<p>Defini que preciso de apenas um Pod (<code>replica</code>) e que as mesmas ser√£o identific√°veis pelas labels: <code>name=db-pod</code>.</p>
<p>Outras duas informa√ß√µes importantes s√£o <code>ports</code> e <code>volumeMounts</code>.</p>
<ul>
<li><code>ports</code> define quais portas dever√£o ser expostas no Pod e permite que possam ser mapeadas nos Services posteriormente. Tamb√©m √© recomendado dar nomes √†s mesmas (<code>mysql-port</code>), assim podemos usar o nome como identificador no lugar de n√∫meros.</li>
<li><code>volumeMounts</code> define todos os volumes do cont√™iner, dessa forma o volume de dados do MySQL precisou ser mapeado (<code>/var/lib/mysql</code>).</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: extensions/v1beta1
<span style="color:#268bd2">kind</span>: Deployment
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-deployment&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">replicas</span>: <span style="color:#2aa198">1</span>
  <span style="color:#268bd2">template</span>:
    <span style="color:#268bd2">metadata</span>:
      <span style="color:#268bd2">labels</span>:
        <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-pod&#34;</span>
    <span style="color:#268bd2">spec</span>:
      <span style="color:#268bd2">containers</span>:
        - <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node&#34;</span>
          <span style="color:#268bd2">image</span>: <span style="color:#2aa198">&#34;lucassabreu/openshift-app-test&#34;</span>
          <span style="color:#268bd2">ports</span>:
            - <span style="color:#268bd2">name</span>: node-port
              <span style="color:#268bd2">containerPort</span>: <span style="color:#2aa198">8080</span>
              <span style="color:#268bd2">protocol</span>: TCP
          <span style="color:#268bd2">env</span>:
            - <span style="color:#268bd2">name</span>: DATABASE_CONNECTION
              <span style="color:#268bd2">value</span>: mysql://appoint:123@db-service:3306/appointments
</code></pre></div><p>O segundo Deployment √© do servidor HTTP, chamei-o de <code>node-deployment</code>. Ele segue as mesmas regras do anterior, sendo at√© mais simples.</p>
<p>A novidade aqui √© o <code>db-service</code>, que vou explicar agora:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: <span style="color:#2aa198">&#34;v1&#34;</span>
<span style="color:#268bd2">kind</span>: Service
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-service&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">ports</span>:
    - <span style="color:#268bd2">port</span>: <span style="color:#2aa198">3306</span>
      <span style="color:#268bd2">targetPort</span>: <span style="color:#2aa198">&#34;mysql-port&#34;</span>
      <span style="color:#268bd2">protocol</span>: TCP
  <span style="color:#268bd2">selector</span>:
    <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;db-pod&#34;</span>
</code></pre></div><p>O <code>db-service</code> √© o nome do Service que defini para agrupar os Pods de banco de dados, o Service ficou bem simples e basicamente tem duas partes:</p>
<ul>
<li><code>selector</code> define uma regra para selecionar quais Pods fazem parte do Service, no caso estou usando uma regra bem simples de <code>name=db-pod</code>.</li>
<li><code>ports</code> permite que voc√™ mapeie as portas dos Pods para uma porta no Service, no caso estou roteando a porta de nome <code>mysql-port</code> para a <code>3306</code> do Service. Assim toda chamada para <code>db-service:3306</code> ser√° direcionada para a <code>mysql-port</code> de um dos Pods.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: <span style="color:#2aa198">&#34;v1&#34;</span>
<span style="color:#268bd2">kind</span>: Service
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-service&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">ports</span>:
    - <span style="color:#268bd2">port</span>: <span style="color:#2aa198">80</span>
      <span style="color:#268bd2">targetPort</span>: <span style="color:#2aa198">&#34;node-port&#34;</span>
      <span style="color:#268bd2">protocol</span>: TCP
  <span style="color:#268bd2">selector</span>:
    <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-pod&#34;</span>
</code></pre></div><p>O <code>node-service</code> segue a mesma l√≥gica, mas para os Pods do servidor HTTP.</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#268bd2">apiVersion</span>: v1
<span style="color:#268bd2">kind</span>: Route
<span style="color:#268bd2">metadata</span>:
  <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-route&#34;</span>
<span style="color:#268bd2">spec</span>:
  <span style="color:#268bd2">to</span>:
    <span style="color:#268bd2">kind</span>: Service
    <span style="color:#268bd2">name</span>: <span style="color:#2aa198">&#34;node-service&#34;</span>
</code></pre></div><p>Por fim criei uma Route para expor o servi√ßo <code>node-service</code> para a Internet. Eu poderia definir qual o nome de host, mas como n√£o o fiz o OpenShift ir√° gerar uma URL automaticamente para mim.</p>
<p>Essa URL pode ser descoberta entrando na Dashboard do OpenShift ou com o comando <code>oc get routes</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ oc get routes
NAME         HOST/PORT                                                  PATH      SERVICES       PORT      TERMINATION
node-route   node-route-medium-example.44fs.preview.openshiftapps.com             node-service   &lt;all&gt;
</code></pre></div><p>Para aplicar as configura√ß√µes no cluster a OpenShift disponibiliza um cliente de linha de comando, que usa basicamente a mesma estrutura do <code>kubectl</code>, o <code>oc</code>. Ent√£o tudo que precisa ser feito √© executar:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">oc apply -f db-deployment.yml,node-deployment.yml,db-srv.yml,node-srv.yml,node-route.yml
<span style="color:#586e75"># Ou</span>
oc apply -f db-deployment.yml
oc apply -f node-deployment.yml
oc apply -f db-srv.yml
oc apply -f node-srv.yml
oc apply -f node-route.yml
</code></pre></div><hr>
<p>As instru√ß√µes de como instalar o cliente e configur√°-lo est√£o nesse
link: <a href="https://console.preview.openshift.com/console/command-line">https://console.preview.openshift.com/console/command-line</a>.</p>
<hr>
<h4 id="-update-20170429-">
	*** Update 2017‚Äì04‚Äì29 ***
	
		<a href="#-update-20170429-" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Se estiver lendo esse artigo algum tempo depois de lan√ßado, a OpenShift fechou o preview e o link anterior n√£o funciona, mas ainda √© poss√≠vel baixar o <code>oc</code> client em:</p>
<p><a href="https://github.com/openshift/origin/releases" title="https://github.com/openshift/origin/releases"><strong>openshift/origin</strong> origin - Enterprise Kubernetes for Developers</a></p>
<hr>
<p>Caso n√£o queira criar os todos esses fontes, pode peg√°-los aqui: <a href="https://github.com/lucassabreu/openshift-next-gen/tree/v1">https://github.com/lucassabreu/openshift-next-gen/tree/v1</a>; ou executar:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone -b v1 <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>    https://github.com/lucassabreu/openshift-next-gen.git
</code></pre></div><hr>
<p>Agora no console do OpenShift dever√£o aparecer todos esses componentes
rodando.</p>


	

<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/openshift-dashboard.png"
		
			width="800" height="496"
		
	/>
	
		<figcaption><p>eu fiz algumas brincadeiras antes de chegar aqui, ent√£o tenho mais vers√µes dos deploys¬†‚ò∫</p></figcaption>
	
</figure>

<p>Caso esteja acompanhando as etapas, voc√™ j√° deve ter visto esse Dashboard, mas caso esteja apenas lendo: esse Dashboard √© a tela principal dos clusters que voc√™ criar no OpenShift; basta clicar aqui, autenticar-se com o GitHub, criar um <strong>Project</strong>, e pronto em <strong>Overview</strong> voc√™ ver√° os componentes surgirem e sumirem em tempo real conforme vai aplicando as configura√ß√µes.</p>
<p>Voltando, nesse momento temos o mesmo comportamento da aplica√ß√£o local, rodando dentro do Kubernetes, empenhando o m√≠nimo poss√≠vel de configura√ß√£o.</p>
<p>Mas existem alguns problemas no que foi definido.</p>
<p>O primeiro √© que os <code>db-pods</code> est√£o totalmente ef√™meros, ou seja, se eu adicionar novos dados nele, no momento que o Pod fosse destru√≠do os dados iriam junto e sem backup¬†!</p>
<p>Irei mostrar como resolver esse problema no pr√≥ximo post.</p>
<p>Pr√≥ximo Post: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/">clique aqui</a></p>]]></content:encoded></item><item><title>Um ambiente simples usando Kubernetes e OpenShift Next Gen‚Ää-‚ÄäParte¬†1</title><link>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/</link><pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate><guid>https://www.lucassabreu.net.br/preview/9/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/</guid><description>Como parte das minhas metas dentro da Coderockr est√° a constru√ß√£o de um cluster usando algumas das ferramentas de orquestra√ß√£o de cont√™ineres que existem no mercado; como o Docker Swarm, Kubernetes, Apache Mesos, etc. Optei pelo Kubernetes...</description><image><url>https://www.lucassabreu.net.br/preview/9/feature/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png</url></image><content:encoded><![CDATA[<figure class="big">
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/header.png"
		
			width="1000" height="165"
		
	/>
	
</figure>

<p>Como parte das minhas metas dentro da <a href="http://blog.coderockr.com">Coderockr</a> est√° a constru√ß√£o de um cluster usando algumas das ferramentas de orquestra√ß√£o de cont√™ineres que existem no mercado; como o <a href="https://docs.docker.com/engine/swarm/">Docker Swarm</a>, <a href="http://kubernetes.io">Kubernetes</a>, <a href="http://mesos.apache.org/">Apache Mesos</a>, etc.</p>
<p>Optei pelo <strong>Kubernetes</strong> no momento, tanto pelo pedigree, criado pelo Google e mantido pela Cloud Native Computing Foundation; quanto pela oferta de grandes clouds como a Red Hat, Azure e Google.</p>
<p>Quando estava avaliando as op√ß√µes dispon√≠veis, o <a href="https://medium.com/@JeanCarloMachad">Jean Carlo Machado</a> (colega da <a href="https://medium.com/@compufacil">CompuF√°cil</a>), me sugeriu usar o <a href="https://blog.openshift.com/next-generation-openshift-online/"><strong>OpenShift Next Gen</strong></a>, a plataforma da Red Hat para Kubernetes, que esta em <a href="https://www.openshift.com/devpreview/">Developer Preview</a> permitindo que voc√™ se cadastre para testar a ferramenta deles por 30 dias.</p>
<p>Isso me salvou de j√° ter de sair pagando para testar, ou ter de fazer o <a href="https://kubernetes.io/docs/getting-started-guides/minikube/">setup do minikube</a> na minha m√°quina, o que n√£o me era muito atrativo.</p>
<p>Assim resolvi dar uma chance a plataforma da Red Hat, e construir um ambiente simples com um servidor HTTP em Node e um banco de dados MySQL, o que j√° me permite cobrir v√°rios aspectos b√°sicos do Kubernetes.</p>
<p>Mas como o texto foi ficando muito grande, achei melhor quebr√°-lo em 4 partes para n√£o cansar quem for ler e que irei publicar nos pr√≥ximos dias.</p>
<p>Nessa primeira parte vou dar uma introdu√ß√£o aos conceitos b√°sicos do Kubernetes, e nas pr√≥ximas irei fazer uso desses conceitos.</p>
<ul>
<li>Parte 2‚Ää-‚ÄäConstruindo o Ambiente: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/">clique aqui</a></li>
<li>Parte 3‚Ää-‚ÄäVolumes Persistentes: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-3/">clique aqui</a></li>
<li>Parte 4‚Ää-‚ÄäSegredos: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-4/">clique aqui</a></li>
</ul>
<hr>
<p>A aplica√ß√£o que constru√≠ usa um <a href="https://www.kaggle.com/joniarroba/noshowappointments">conjunto de dados sobre faltas em consultas</a> que achei no <a href="https://www.kaggle.com/">Kaggle</a> e gera os gr√°ficos abaixo, podendo escolher o dia da semana como filtro.</p>


	

<figure >
	<img
		class="lazyload blur-up"
		loading="lazy"
		data-src="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-1/app-view.png"
		
			width="800" height="541"
		
	/>
	
		<figcaption><p>O fonte dessa aplica√ß√£o pode ser encontrado aqui: &lt;https://github.com/lucassabreu/openshift-next-gen/tree/app&gt;</p></figcaption>
	
</figure>

<p>Ent√£o publiquei no <a href="http://hub.docker.com">Docker Hub</a> uma imagem para a aplica√ß√£o (<a href="https://hub.docker.com/r/lucassabreu/openshift-app-test/">lucassabreu/openshift-app-test</a>) e outra para o banco de dados (<a href="https://hub.docker.com/r/lucassabreu/openshift-mysql-test/">lucassabreu/openshift-mysql-test</a>)‚Ää-‚Ääessa imagem √© um MySQL normal, mas que adicionei um dump da base que vou usar para facilitar o deploy.</p>
<p>Agora se eu quiser executar essa aplica√ß√£o na minha m√°quina, posso simplesmente executar os seguintes comando do Docker e terei o servidor me respondendo em <code>http://localhost</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#719e07">#!/bin/bash
</span><span style="color:#719e07"></span>docker run -d --name db-test <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  -e <span style="color:#268bd2">MYSQL_ROOT_PASSWORD</span><span style="color:#719e07">=</span>root -e <span style="color:#268bd2">MYSQL_DATABASE</span><span style="color:#719e07">=</span>appointments <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  -e <span style="color:#268bd2">MYSQL_USER</span><span style="color:#719e07">=</span>appoint -e <span style="color:#268bd2">MYSQL_PASSWORD</span><span style="color:#719e07">=</span><span style="color:#2aa198">123</span> <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  lucassabreu/openshift-mysql-test

docker run -d --name app-test --link db-test:db <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  -e <span style="color:#268bd2">DATABASE_CONNECTION</span><span style="color:#719e07">=</span>mysql://appoint:123@<span style="color:#268bd2">$db</span>:3306/appointments <span style="color:#cb4b16">\
</span><span style="color:#cb4b16"></span>  -p 80:8080 lucassabreu/openshift-app-test
</code></pre></div><p>Certo, agora que tenho certeza de que a minha aplica√ß√£o est√° operacional, comecei a criar os objetos do Kubernetes, mas antes √© importante entender alguns conceitos da plataforma para n√£o ficar muito perdido:</p>
<h4 id="podhttpskubernetesiodocsuser-guidepods">
	<a href="https://kubernetes.io/docs/user-guide/pods/">Pod</a>
	
		<a href="#podhttpskubernetesiodocsuser-guidepods" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Este √© o menor componente do Kubernetes, representa um n√≥ no cluster, executando um ou mais cont√™ineres que entregam uma mesma fun√ß√£o.</p>
<p>Eles tem a caracter√≠stica de serem descart√°veis, ou seja, se eventualmente acontecer algum problema a um Pod, este pode ser destru√≠do sem nenhum efeito colateral ou remorso.</p>
<h4 id="deploymenthttpskubernetesiodocsuser-guidedeployments">
	<a href="https://kubernetes.io/docs/user-guide/deployments/">Deployment</a>
	
		<a href="#deploymenthttpskubernetesiodocsuser-guidedeployments" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Como o nome sugere controla o deploy de Pods dentro do cluster. Quando se cria esse componente, deve-se informar um template de Pod e quantos destes voc√™ precisa, e se necess√°rio uma regra para criar mais inst√¢ncias.</p>
<p>Ele ir√° garantir duas coisas principalmente: que existam suficientes Pods quanto foi definido, e que os mesmos estejam atualizados em rela√ß√£o ao template que foi definido.</p>
<p>Ent√£o caso voc√™ mude algo no template o Deployment vai subir novos Pods e destruir os antigos para manter a expectativa (ele tamb√©m &ldquo;versiona&rdquo; os deploys, ent√£o se algo explodir d√° para voltar atr√°s).</p>
<h4 id="servicehttpskubernetesiodocsuser-guideservices">
	<a href="https://kubernetes.io/docs/user-guide/services/">Service</a>
	
		<a href="#servicehttpskubernetesiodocsuser-guideservices" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Como os Pods al√©m de ef√™meros, podem existir em n√∫meros variados por culpa dos Deployments, n√£o h√° forma confi√°vel de tentar conectar dois Pods diretamente, seja porque o Pod que voc√™ est√° dependendo pode morrer e quando voltar ter√° outro IP, e provavelmente outro nome, ou porque o Pod que voc√™ &ldquo;fixou&rdquo; pode n√£o ser o mas indicado (menos ocupado ou mais pr√≥ximo).</p>
<p>Para resolver esse problema existem os Services, em vez de tentar fazer as chamadas diretamente para um Pod, podemos chamar pelo nome de um Service e este ir√° rotear para um Pod que esteja abaixo dele.</p>
<p>√â importante ressaltar que os Services fazem &ldquo;apenas&rdquo; a descoberta dos Pods, eles n√£o os mant√™m ligados, isso √© responsabilidade dos Deployments.</p>
<h4 id="routehttpsdocsopenshiftorglatestarchitecturecore_conceptsrouteshtml">
	<a href="https://docs.openshift.org/latest/architecture/core_concepts/routes.html">Route</a>
	
		<a href="#routehttpsdocsopenshiftorglatestarchitecturecore_conceptsrouteshtml" class="heading-anchor"
			aria-label="copy link to this section"
			title="Copy link to this section"
			>
			<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 512 512">
				<g>
					<g>
						<g>
							<path d="M480.7,11H130.4c-11.3,0-20.4,9.1-20.4,20.4v60.3H31.5c-11.3,0-20.4,9.1-20.4,20.4v368.5c0,11.3,9.1,20.4,20.4,20.4		 h350.3c11.3,0,20.4-9.1,20.4-20.4v-60.3h78.5c11.3,0,20.4-9.1,20.4-20.4V31.4C501.1,20.1,491.9,11,480.7,11z M361.3,460.2H51.9		 V132.5h309.4V460.2z M460.2,379.5h-58.1V112.1c0-11.3-9.1-20.4-20.4-20.4h-231V51.8h309.4V379.5z"/>
							<path d="m127.8,242.6h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.3 9.1,20.4 20.4,20.4z"/>
							<path d="m127.8,390.9h157.7c11.3,0 20.4-9.1 20.4-20.4 0-11.3-9.1-20.4-20.4-20.4h-157.7c-11.3,0-20.4,9.1-20.4,20.4 0,11.2 9.1,20.4 20.4,20.4z"/>
						</g>
					</g>
				</g>
			</svg>
		</a>
	
</h4>
<p>Permitem que voc√™ exponha Services para a rede externa e tamb√©m permite algumas regras de proxy para melhor apresent√°-los.</p>
<p>Embora seja poss√≠vel fazer a exposi√ß√£o de Services para a rede externa com Kubernetes, na plataforma da OpenShift √© necess√°rio o uso do componente Route para isso.</p>
<hr>
<p>Como comentei no in√≠cio, estou escrevendo uma s√©rie de postagens para mostrar como usar o b√°sico do Kubernetes, e no pr√≥ximo post irei usar os conceitos que acabei de descrever para implementar o ambiente.</p>
<p>Pr√≥ximo Post: <a href="/post/um-ambiente-simples-usando-kubernetes-e-openshift-next-gen-parte-2/">clique aqui</a></p>]]></content:encoded></item></channel></rss>